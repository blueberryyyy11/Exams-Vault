**Материал для подготовки к экзамену по ООП**

### 1. Основы ООП

- **Классы и объекты**: класс — это шаблон, описывающий структуру и поведение объектов. Объект — экземпляр класса.
- **Инкапсуляция**: механизм скрытия деталей реализации и предоставления доступа к данным через интерфейсы (геттеры, сеттеры).
- **Наследование**: возможность создания нового класса на основе существующего с добавлением новых данных или методов.
- **Полиморфизм**: способность объектов обрабатывать вызовы методов в зависимости от их типов (виртуальные функции).

### 2. Работа со ссылками

#### Вопрос: "Выберите правильные варианты объявления ссылки на переменную `x` типа `int`"

**Пример правильных объявлений:**

- `const int& y = x;`
- `int& y = x;`
- `int&& y = x;` (для r-value ссылок)

#### Теория:

- `const int&` — ссылка на константное значение (нельзя изменять через ссылку).
- `int&` — обычная ссылка на изменяемую переменную.
- `int&&` — r-value ссылка, которая используется для временных объектов.

### 3. Функции и их поведение

#### Пример вопроса:

Что выведет следующая программа?

```cpp
#include <iostream>

void f(int& a, const int& b) {
    std::cout << b;
    a = 1;
    std::cout << b;
}

int main() {
    int x = 0;
    f(x, x);
}
```

**Ответ:**

- Опция: Undefined Behavior (некорректное поведение, так как `b` и `a` ссылаются на один объект, изменяемый в процессе).

### 4. Виртуальные функции и абстрактные классы

- **Чисто виртуальная функция**:
    
    ```cpp
    struct A {
        virtual void func() = 0; // Чисто виртуальная функция
    };
    ```
    
- **Абстрактный класс**: содержит хотя бы одну чисто виртуальную функцию. Нельзя создать экземпляр такого класса.

#### Пример вопроса:

Определите абстрактный класс и чисто виртуальную функцию. Какое главное свойство абстрактного класса? **Ответ:** Главное свойство — невозможность создания объекта абстрактного класса.

### 5. Конструкторы и деструкторы

#### Пример вопроса:

Пусть класс `Complex` представляет комплексные числа. Напишите декларацию конструктора копирования и оператора присваивания.

```cpp
class Complex {
public:
    Complex(const Complex& other); // Конструктор копирования
    Complex& operator=(const Complex& other); // Оператор копирования
};
```

### 6. Правила перегрузки функций

- **Перегрузка (overloading)** — функции с одинаковыми именами, но разными параметрами.
- **Переопределение (overriding)** — изменение поведения виртуальной функции базового класса в производном.

#### Пример вопроса:

Приведите пример перегрузки и переопределения. В чем их отличие? **Ответ:**

- Перегрузка: функции с разными сигнатурами внутри одного класса.
- Переопределение: одна и та же виртуальная функция, но с разным поведением в производном классе.

### 7. Работа с `std::move`

#### Пример вопроса:

Что выведет следующий код?

```cpp
#include <utility>
#include <iostream>

void foo(const int& x) {
    std::cout << "1";
}

void foo(const int&& x) {
    std::cout << "2";
}

int main() {
    int a = 10;
    foo(a);
    foo(std::move(a));
}
```

**Ответ:** Вывод будет `12`.

### 8. Члены-методы класса `std::string`

#### Пример вопроса:

Какие члены-методы `std::string` вызываются в коде?

```cpp
std::string str1{"abcd"};
std::string str2 = str1;
std::move(str1);
```

**Ответ:**

- Конструктор копирования,
- Move-конструктор.

### 9. Дополнительные практические задачи

1. Напишите реализацию класса `A` из следующего объявления:

```cpp
struct A {
    const int x;
    A();
    int getX() const;
};
```

**Решение:**

```cpp
#include "A.h"

A::A() : x(0) {}
int A::getX() const { return x; }
```

2. Реализуйте шаблонную функцию, которая принимает один аргумент и печатает его:

```cpp
template <typename T>
void print(const T& value) {
    std::cout << value;
}
```

### 10. Дополнительно из предоставленных изображений

#### Вопрос: Какие методы вызываются в следующем коде?

```cpp
std::string f() {
    std::string str{"abcd"};
    return str;
}

int main() {
    std::string s = f();
}
```

**Ответ:**

- Конструктор копирования,
- Деструктор.

#### Пример задачи с виртуальной функцией

```cpp
#include <iostream>

struct A {
    virtual void f() { std::cout << "A"; }
};

struct B : A {
    void f() override { std::cout << "B"; }
};

int main() {
    A* ptr = new B;
    ptr->f();
    delete ptr;
}
```

**Ответ:** Вывод: `B`. Вызов виртуальной функции идёт в соответствии с типом объекта, а не указателя.

#### Перегрузка и переопределение:

```cpp
#include <iostream>

void print(int x) {
    std::cout << "int";
}

void print(double x) {
    std::cout << "double";
}

struct Base {
    virtual void display() { std::cout << "Base"; }
};

struct Derived : Base {
    void display() override { std::cout << "Derived"; }
};

int main() {
    print(10);       // Перегрузка
    print(10.5);     // Перегрузка

    Base* obj = new Derived;
    obj->display();  // Переопределение
    delete obj;
}
```

**Ответ:**

- Перегрузка: функции `print` обрабатывают разные типы параметров.
- Переопределение: метод `display` в производном классе изменяет поведение базового класса.