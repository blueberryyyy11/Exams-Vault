**Процессы. Основные свойства процесса и древовидная структура. Виртуальная память процесса. Описание системных вызовов для создания и управления процессами**.

### Что такое процесс?
Когда у нас есть программа, это какой-то набор инструкций для процессора. Чаще всего это файл, записанный где-то в памяти, и его можно запустить. Когда мы его запускаем, операционная система даёт этой программе некоторое количество свободы: доступ к железу, компьютеру, ресурсам. Эта программа может работать. В процессе, когда программа запущена, работает, потребляет ресурсы, использует процессор, память и так далее, — это и есть процесс. Это программа, которая функционирует.

**Определение:**  
Процесс — это программа в состоянии выполнения.

Если операционная система даёт доступ к ресурсам компьютера каким-то программам, то просто так остановиться на этом сегодня уже нельзя. Это было в меньшей степени проблемой, когда на заре компьютеров у нас был один процесс в один момент времени, и нам не нужно было думать о том, какой процесс к чему имеет доступ. У нас был всего лишь один процесс в любой момент времени, и можно было не волноваться, что он заденет какой-то другой процесс. Когда этот процесс завершался, можно было забыть обо всём, запустить новый процесс — и проблем не возникало.

Как только появилось желание и возможность запускать несколько процессов одновременно, это чаще всего оказалось иллюзией с точки зрения пользователя. С точки зрения процессов зачастую они не могут работать одновременно. Чтобы поддерживать эту иллюзию, операционная система должна не только давать доступ к ресурсам, но и брать на себя ответственность за этот доступ, за то, как эти процессы будут двигаться, какую свободу манёвров можно им давать. Если что-то пойдёт не так, виновата будет операционная система. Но самое главное — она должна защищать эти ресурсы от других процессов.

Операционная система предоставляет доступ к ресурсам (память, устройства ввода-вывода, интерфейсы, дополнительные устройства) нескольким приложениям одновременно. Иллюзия многозадачности достигается за счёт быстрого переключения процессора между приложениями. Процессор в каждый момент времени выполняет только одну задачу. Быстрое переключение между процессами создаёт впечатление одновременной работы нескольких приложений. Операционная система должна учитывать разницу в скорости работы процессора (очень быстрый) и устройств ввода-вывода (очень медленные). Для максимальной эффективности ресурсы должны быть организованы так, чтобы процессор не простаивал, ожидая медленные устройства.
![[Pasted image 20250121002416.png]]

Примерно так выглядит процесс. Структура данных, используемая ОС для представления процесса, называется **Process Control Block** (то, что в зелёных ячейках).  
Кроме самого кода, который запускается, у нас должны быть какие-то данные, связанные с этой программой, и некий контекст. Контекст — это, грубо говоря, окружение: представьте себе, мы — процесс, нам нужно помнить, где мы находимся. Всё это находится в памяти. Это не что иное, как какие-то данные, и если бы вы просто заглянули в память и увидели там, допустим, байты, то вы бы особо не поняли разницы между программой, контекстом этой программы или просто каким-то пользовательским файлом. Это просто какие-то данные.

Процесс состоит из нескольких элементов, и, в зависимости от операционной архитектуры и от конкретных задач, их может быть разное количество, но основные идеи следующие:
1. **Идентификатор:**
    уникальное имя, по которому этот процесс можно идентифицировать. Так как ОС будет постоянно переключаться между процессами, ему нужен способ как-то назвать процесс и сказать "Эй ты, я переключаюсь на тебя" или "Эй ты, уйди и жди чего-нибудь". Естественно этот идентификатор должен быть уникальным. Часто используется просто какое-то число. 
    
2. **Состояние:**
    описание того, на каком этапе сейчас процесс. 
    
3. **Приоритет:**
    каждый процесс можно оценить относительно других процессов. Если процесс управляет памятью или файлами, то это важнее чем процесс, который рисует котика (спорный момент, но ОС отклонил ваши протесты).
    
4. **Счётчик команд (Program Counter):**
    в зависимости от архитектуры показывает на текующий или следующий процесс. 
    
5. **Указатели на память:**
	Ссылки на области памяти, используемые процессом.
6. **Контекст:**
    Когда процесс временно приостанавливается, всё его состояние должно быть сохранено, чтобы он мог быть возобновлён с того же места. Это включает:
	- Позицию указателей файлов.
	- Состояние регистров и памяти.

	Информация о процессах хранится в таблице процессов, которая представляет собой массив структур, по одной для каждого активного процесса.
    
7. **Информация о статусе ввода/вывода (I/O):**
    - Данные о состоянии операций ввода/вывода, связанных с процессом.
8. **Другая информация:**
    - Дополнительные метаданные, необходимые для управления процессом.


#### Простая модель состояний процесса:
![[Pasted image 20250121004414.png]]
Если посмотреть на вселенную с точки зрения процесса, то всё очень просто. В какой-то момент процесса не существует. Затем он создаётся, но ещё не запущен: он находится где-то в памяти (в принципе, он может находиться где угодно, но в данный момент не в процессе работы).

В какой-то момент процессор, наконец, уделяет этому процессу некоторое внимание, и процесс запускается. После этого он может либо завершиться и прекратить своё существование, либо встать на паузу и снова стать незапущенным. Что дальше делает центральный процессор — переключается ли он или просто «не любит» этот процесс — уже неважно.

#### Очередь:
![[Pasted image 20250121004907.png]]
Как только процесс перестаёт работать и ему нужно встать на паузу, но в будущем он знает, что будет запущен заново, либо мы просто создаём новый процесс, перед ним, скорее всего, уже есть очередь процессов, которые ждут своего шанса поработать на процессоре. Поэтому структура выглядит примерно так: у нас есть очередь, из которой, возможно, в порядке приоритета, а возможно, просто по порядку процессы попадают в область, где они могут пользоваться процессором.

С точки зрения процесса жизнь довольно тривиальна. Большую часть времени процесс ждёт: он либо ждёт чего-то, либо ждёт своей очереди, либо находится в очереди. Но лишь небольшой процент времени процесс действительно использует процессор.

Что же происходит в этот волшебный момент создания процесса?  
Чаще всего процессы создаются самой операционной системой (естественно, причиной этому может быть пользователь, расписание или что-то ещё, но сам процесс создаётся именно операционной системой).

Зачастую процессы могут создавать свои дочерние процессы — это называется **process spawning**.
Родительский процесс -> дочерний процесс 
![[Pasted image 20250120203119.webp]]
Процессы, работающие совместно, могут обмениваться данными и синхронизировать действия через механизмы межпроцессного взаимодействия (**IPC**, Inter-Process Communication). Это включает передачу сообщений и сигналов.

- **Сигналы** — это программные аналоги аппаратных прерываний. Например, сигнал может уведомить процесс об истечении таймера или необходимости повторной отправки сообщения.

---

### Уничтожение процесса

Для уничтожения процесса необходимо определить, что процесс завершён. Это может произойти в следующих случаях:

1. **Специальный сигнал (например, HALT):**
    - Операционная система получает сигнал, понимает, что процесс должен быть уничтожен, освобождает память и ресурсы, связанные с этим процессом.
2. **Действие пользователя:**
    - Пользователь вручную завершает процесс, например, через диспетчер задач.
3. **Ошибка:**
    - Процесс завершает работу из-за сбоя или ошибки выполнения.
4. **Завершение родительского процесса:**
    - Когда родительский процесс завершён, все его дочерние процессы также уничтожаются.

---

### Состояния процессов

1. **Готовы к выполнению (Ready):**
    
    - Процессы, которые не запущены, но полностью готовы к выполнению. Они находятся в очереди и ждут своей очереди на использование процессора.
2. **Заблокированы (Blocked):**
    
    - Процессы, которые не могут выполняться, так как ожидают какого-либо события, например, завершения операции ввода/вывода (чтение данных с диска, ожидание ответа сети и т.д.).

Таким образом, жизненный цикл процесса включает в себя переходы между состояниями: создание, ожидание, выполнение и завершение. Эти состояния позволяют операционной системе эффективно управлять ресурсами и обеспечивать стабильную работу системы.
![[Pasted image 20250121010742.png]]
ИИз состояния "запущенного" у нас есть два пути назад: переход к "готов" по тайм-ауту (то есть процесс поработал столько времени, сколько ему нужно, и он готов продолжать, но процессору пора сменить контекст на какой-то другой процесс, поэтому такой процесс приходит в очередь). Второй путь назад — это когда процесс начинает ожидать что-то более медленное, чем процессор, и чаще всего это бывает устройство ввода-вывода. Иногда это бывает пользовательский ввод, что тоже очень медленно (даже если процесс ждёт, когда я нажму "Окей", и я думаю, что "вот, покажите мне окно, я сразу нажму "Окей"", на самом деле пока это окно появится на экране, пока я проведу туда мышку или пока я дотянусь до кнопки Enter, пройдёт немыслимое количество времени, просто колоссальное. За это количество времени можно столько всего сделать, и компьютер это делает). Поэтому можно такой процесс перевести в состояние "заблокирован".

![[Pasted image 20250121011559.png]]Есть также двойная очередь, чтобы процессы которые ждут разных событий (например какой-то процесс ждёт ответа жёсткого диска и это медленно, но гораздо быстрее чем ждать человека), стояли в разных очередях.

![[Pasted image 20250121011739.png]]И есть множоственная очередь, чтобы ждать меньше и работать больше.

---

![[Pasted image 20250120211328.png]]

### **Что такое init**

**`init`** — это первая программа, запускаемая ядром операционной системы после завершения процесса загрузки. Она отвечает за инициализацию всех остальных процессов в системе и выполняет функции управления состоянием системы, таких как переключение между уровнями выполнения (runlevels). **`init`** традиционно используется в Unix-подобных операционных системах и является "прародителем" всех других процессов.

***Основные функции `init`:***

1. **Запуск других процессов**:
    
    - После загрузки ядро передает управление программе `init`, которая начинает запуск системных служб (демонов) и процессов, необходимых для работы системы.

2. **Обработка сигналов от процессов**:
    
    - `init` управляет завершением, рестартом и контролем состояния дочерних процессов.

***Особенности `init`:***

1. **PID 1**:
    - Процесс `init` всегда имеет идентификатор процесса (PID) равный **1**. Он является родителем всех остальных процессов в системе.
2. . **Простота реализации**:
    - `init` выполняет только базовые функции управления, что делает его относительно простым, но ограниченным по сравнению с современными системами инициализации (например, `systemd`).


- **Init vs Systemd**
    **`init`** и **`systemd`** — это системы инициализации, используемые в операционных системах семейства Unix для управления процессами при загрузке системы. **`systemd`** является более современной и универсальной системой управления, разработанной для улучшения производительности и расширенной функциональности.
    
    ### Основные отличия:
    
    - **Параллелизация загрузки**:
        - **`init`**: Инициализация выполняется последовательно, каждый процесс запускается один за другим, что может замедлить загрузку.
        - **`systemd`**: Поддерживает параллельный запуск служб, что сокращает время загрузки, поскольку независимые службы запускаются одновременно.
    - **Функциональность**:
        - **`init`**: Обладает минимальным набором функций, основная задача — запуск процессов.
        - **`systemd`**: Включает широкий спектр дополнительных функций, таких как управление таймерами, сокетами, таргетами (аналог уровня выполнения в init) и зависимостями между службами.
    
    ### Итог:
    
    - **`init`**: Простая, но устаревшая система инициализации, ограниченная по возможностям.
    - **`systemd`**: Мощный, гибкий и производительный инструмент, ставший стандартом в большинстве современных дистрибутивов Linux.




#### Межпроцессное взаимодействие:


#### UID и права пользователей:

- Каждому пользователю присваивается уникальный идентификатор (UID).
- Дочерние процессы наследуют UID родительского процесса.
- Особый UID суперпользователя (Administrator в Windows) позволяет обходить ограничения безопасности.


---
### Виртуальная память процесса
*(про это подробнее в VirtualMemory.pdf)*

**Виртуальная память** — это механизм управления памятью, предоставляемый операционной системой, который создает иллюзию наличия большого непрерывного адресного пространства для каждого процесса, даже если физической памяти (ОЗУ) недостаточно. Этот механизм используется в большинстве современных операционных систем, таких как Linux, Windows и macOS.

### Основные цели виртуальной памяти:

1. **Изоляция процессов**: Каждый процесс видит свое собственное изолированное адресное пространство, что предотвращает доступ одного процесса к памяти другого.
2. **Упрощение программирования**: Разработчикам не нужно беспокоиться о физической памяти; все адреса кажутся последовательными.
3. **Эффективное использование памяти**: Виртуальная память позволяет запускать больше процессов, чем позволяет объем физической памяти, за счет использования дискового пространства (файла подкачки).
4. **Механизмы защиты**: Обеспечивает контроль доступа к памяти (например, чтение, запись, исполнение).


### Адресное пространство процесса

Каждому процессу предоставляется свое **виртуальное адресное пространство**, которое делится на следующие сегменты:

1. **Текстовый сегмент**:
    
    - Хранит машинный код программы (инструкции).
    - Обычно только для чтения, чтобы предотвратить случайные изменения кода.
    - Общий между процессами при запуске одинаковых программ.
2. **Сегмент данных**:
    
    - Хранит глобальные и статические переменные.
    - Подразделяется на две части:
        - **Инициализированные данные**: Глобальные переменные с явным значением (например, `int x = 5`).
        - **Неинициализированные данные (BSS)**: Глобальные переменные, которым не присвоено значение (например, `int y;`).
3. **Куча (Heap)**:
    
    - Динамическая память, выделяемая и освобождаемая вручную с помощью `malloc()`/`free()` в C или `new`/`delete` в C++.
    - Увеличивается вниз (в сторону больших адресов) по мере выделения памяти.
4. **Стек (Stack)**:
    
    - Используется для хранения локальных переменных и данных вызова функций (например, адреса возврата).
    - Растет в сторону меньших адресов.
    - Управляется автоматически.
5. **Маппированные сегменты**:
    
    - Используются для отображения файлов в память с помощью `mmap()`.
    - Применяются для работы с большими файлами или совместного использования памяти между процессами.

### Перевод виртуальных адресов в физические

Операционная система и аппаратное обеспечение (CPU) совместно преобразуют виртуальные адреса в физические через механизм, называемый **таблицами страниц**.

1. **Страница и фрейм**:
    
    - Память делится на **страницы** (виртуальная память) и **фреймы** (физическая память).
    - Размер страницы фиксирован (обычно 4 KB).
2. **Таблицы страниц**:
    
    - Для каждого процесса хранится таблица страниц, связывающая виртуальные адреса со страницами физической памяти.
    - Таблицы страниц хранятся в памяти, а CPU использует **TLB** (Translation Lookaside Buffer) для кэширования наиболее часто используемых преобразований.
3. **Механизм подкачки**:
    
    - Если страница, запрашиваемая процессом, отсутствует в физической памяти (**page fault**), ОС загружает её с диска (файла подкачки или свопа).


### Свойства виртуальной памяти

1. **Отображение памяти по запросу**:
    
    - ОС выделяет физическую память только тогда, когда она реально нужна процессу, вместо выделения всей памяти сразу.
2. **Копирование при записи (Copy-on-Write, COW)**:
    
    - Если несколько процессов разделяют одну и ту же страницу (например, при `fork()`), копия страницы создается только при попытке записи.
3. **Файлы подкачки (Swap)**:
    
    - Когда физическая память заканчивается, менее используемые страницы выгружаются на диск.
    - Это замедляет работу, так как диск значительно медленнее ОЗУ.
4. **Права доступа**:
    
    - Каждой странице можно присвоить права (например, только для чтения или только для выполнения), что предотвращает выполнение вредоносного кода.


### Пример работы виртуальной памяти:

1. Программа запрашивает доступ к виртуальному адресу `0x7FFF1234`.
2. CPU проверяет TLB на наличие преобразования этого адреса. Если преобразование есть, физический адрес используется немедленно.
3. Если преобразования нет, происходит обращение к таблице страниц процесса для нахождения физического адреса.
4. Если страница отсутствует в физической памяти (**page fault**), ОС загружает её с диска в оперативную память.

---

### Системные вызовы для работы с процессами
![[Pasted image 20250120204153.png]]

#### Создание процессов:

**Fork(), exec(), wait(), exit()**

- Вызов системы `fork()` позволяет одному процессу, называемому родителем, создать новый процесс — дочерний. Новый процесс является (почти) точной копией родителя: дочерний процесс получает копии стека, данных, кучи и текстового сегмента родительского процесса.
	
- Функция `exit(status)` завершает выполнение процесса, освобождая все ресурсы (память, открытые файловые дескрипторы и т.д.), которые использовал процесс, для их повторного использования ядром. Аргумент `status` — это целое число, которое указывает код завершения процесса ( **Код `0`:** успешное завершение процесса без ошибок. **Код, отличный от `0`:** обычно указывает на ошибку или ненормальное завершение процесса.). С помощью вызова системы `wait()` родитель может получить этот код.
	
- Системный вызов `wait(&status)` выполняет две функции. Во-первых, если ни один дочерний процесс не завершился вызовом `exit()`, то `wait()` приостанавливает выполнение родительского процесса до тех пор, пока один из дочерних не завершится. Во-вторых, статус завершения дочернего процесса возвращается через аргумент `status`.
	
- Системный вызов `execve(pathname, argv, envp)` загружает новую программу (указанную в `pathname`) в память процесса. Аргументы запуска программы передаются через `argv`, а окружение — через `envp`. При этом существующий текст программы удаляется, а стек, данные и сегменты кучи создаются заново для новой программы.
![[Drawing 2025-01-21 04.01.36.excalidraw]]
![[Drawing 2025-01-21 04.03.49.excalidraw]]


**vfork()**
    
- Как и `fork()`, системный вызов `vfork()` используется для создания нового дочернего процесса. Однако `vfork()` предназначен для использования в ситуациях, когда дочерний процесс немедленно вызывает `exec()`.

Два отличия `vfork()` от `fork()`, делающие его более эффективным:

1. Дочерний процесс не копирует виртуальные страницы памяти и таблицы страниц родителя. Вместо этого дочерний процесс временно использует память родительского процесса, пока не выполнит `exec()` или `_exit()`.
	
2. Выполнение родительского процесса приостанавливается до тех пор, пока дочерний не завершится или не выполнит `exec()`.
	

#### Управление процессами:

1. **`wait()` и `waitpid()`**:
    - Ожидание завершения дочернего процесса.
2. **`kill()`**:
    - Отправка сигнала процессу для завершения или выполнения другой команды.
3. **`exit()`**:
    - Завершение процесса.
4. **`getpid()` и `getppid()`**:
    - Получение PID текущего и родительского процессов.


---
### **Сироты и зомби**

- **Сироты**: Если родительский процесс завершился, а его дочерний процесс остался активным, то он становится "сиротой". В этом случае новым родителем сироты становится процесс `init` с идентификатором PID 1. Если вызвать `getppid()` для сироты, результатом будет значение `1`.
        
- **Зомби**: Если дочерний процесс завершился раньше, чем родитель успел вызвать `wait()`, то дочерний процесс переходит в состояние "зомби". Это позволяет родителю позже получить статус завершения дочернего процесса. Зомби освобождает почти все ресурсы, но занимает запись в таблице процессов. Зомби нельзя завершить даже сигналом `SIGKILL`.

### **Демоны**
    
Демон — это процесс, обладающий следующими характеристиками:

- Он работает длительное время, часто начинаясь при запуске системы и завершаясь только при её выключении.
- Работает в фоновом режиме и не имеет управляющего терминала. Это предотвращает автоматическую генерацию сигналов управления задачами (таких как `SIGINT`, `SIGTSTP` и `SIGHUP`) для демона.


Пример работы с процессами на C:
```c
#include <stdio.h>
#include <unistd.h>
#include <sys/wait.h>

int main() {
    pid_t pid = fork();
    if (pid == 0) {
        // Дочерний процесс
        printf("Дочерний процесс. PID: %d\n", getpid());
        execlp("/bin/ls", "ls", NULL);
    } else {
        // Родительский процесс
        wait(NULL); // Ожидание завершения дочернего процесса
        printf("Родительский процесс. PID: %d\n", getpid());
    }
    return 0;
}
```


### Инициализация процессов

- **Foreground process**: Работает по умолчанию, принимает ввод с клавиатуры, выводит результат на экран. Например:

```bash
$ pwd
/home/geeksforgeeks/root
```

Если процесс длительный, другие команды не могут быть запущены, пока он не завершится.

- **Background process**: Работает без ввода с клавиатуры. Добавление `&` запускает процесс в фоне:

```bash
$ pwd &
```


#### Отслеживание процессов:

Команда `ps` позволяет отобразить все запущенные процессы:

```bash
$ ps
PID       TTY      TIME        CMD
19        pts/1    00:00:00    sh
24        pts/1    00:00:00    ps
```

Для более подробной информации:

```bash
$ ps -f
UID      PID  PPID C STIME    TTY        TIME CMD
52471     19     1 0 07:20    pts/1  00:00:00 sh
52471     25    19 0 08:04    pts/1  00:00:00 ps -f
```

Для отслеживания конкретного процесса по PID:

```bash
$ ps 19
```

#### Завершение процессов:

- В переднем плане — `Ctrl + C`.
- Для фоновых процессов — `kill` с PID:

```bash
$ kill 19
```

Если процесс игнорирует команду, используется `kill -9`.


### Код для создания и управления процессами

Пример создания дочернего процесса и передачи управления другой программе:
```cpp
#include <iostream>
#include <unistd.h>
#include <sys/wait.h>

using namespace std;

int main() {
    char* args[] = {"ls", "-l", NULL};
    pid_t pid = fork();
    if (pid == 0) {
        // Дочерний процесс
        execvp("ls", args);
        cerr << "Ошибка при запуске execvp" << endl;
        return -1;
    } else {
        // Родительский процесс
        wait(NULL);
        cout << "Дочерний процесс завершён." << endl;
    }
    return 0;
}
```
1. **Создание аргументов для команды:**
    `char* args[] = {"ls", "-l", NULL};`
    
    - Массив строк `args` содержит:
        - `"ls"` — команда для отображения содержимого текущей директории.
        - `"-l"` — опция для вывода в подробном формате.
        - `NULL` — маркер окончания массива аргументов.
    - Массив `args` передаётся функции `execvp()`.


2. **Создание дочернего процесса:**
    
    `pid_t pid = fork();`
    
    - `fork()` создаёт копию текущего процесса:
        - В дочернем процессе `fork()` возвращает `0`.
        - В родительском процессе `fork()` возвращает PID дочернего процесса.
    - Теперь у нас два процесса:
        - Родительский.
        - Дочерний.

4. **Ветвление выполнения:**
```c
    if (pid == 0) {
    // Дочерний процесс
    execvp("ls", args);
    cerr << "Ошибка при запуске execvp" << endl;
    return -1;
} else {
    // Родительский процесс
    wait(NULL);
    cout << "Дочерний процесс завершён." << endl;
}

```

- **Дочерний процесс (`pid == 0`)**:

	1. Выполняется системный вызов `execvp("ls", args)`.
		- `execvp()` заменяет текущий процесс (дочерний) программой, указанной в аргументе (`ls`).
		- Если `execvp()` выполнится успешно, код после него не будет выполнен, так как процесс заменяется.
	2. Если `execvp()` не удалось (например, команда `ls` не найдена), выводится сообщение об ошибке через `cerr`, и процесс завершает работу с кодом `-1`.
- **Родительский процесс (`pid > 0`)**:

	1. Выполняется вызов `wait(NULL)`, чтобы дождаться завершения дочернего процесса.
		- Функция `wait()` блокирует выполнение родительского процесса, пока дочерний процесс не завершится.
	2. После завершения дочернего процесса выводится сообщение `"Дочерний процесс завершён."`.