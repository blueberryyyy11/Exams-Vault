**Исполняемые файлы и программные библиотеки: их структура и отображение в память**


### **Что такое исполняемые файлы**

Исполняемые файлы содержат инструкции и данные, которые операционная система загружает в память и передаёт процессору для выполнения. Они имеют строго определённую структуру, которая описывает, как загружать и использовать их содержимое.

##### **Форматы исполняемых файлов**

1. **ELF (Executable and Linkable Format)**
   - Основной формат в Linux и других Unix-подобных системах.
   - Позволяет эффективно управлять памятью и использовать динамические библиотеки.

2. **PE (Portable Executable)**
   - Используется в Windows.
   - Обеспечивает интеграцию с архитектурой Windows и загрузчиком системы.

3. **Mach-O**
   - Формат, применяемый в macOS.
   - Адаптирован для интеграции с ядром Darwin.


### **Структура ELF-файла**

ELF-файлы разбиты на секции и сегменты. Основные элементы:

1. **Header (Заголовок):**
   - Указывает тип файла (исполняемый, объектный или библиотека).
   - Содержит точку входа (entry point) — адрес начала выполнения программы.

2. **Program Headers:**
   - Описывают сегменты, которые должны быть загружены в память.

3. **Section Headers:**
   - Определяют секции, используемые компоновщиком (linker) и отладчиком (debugger).

4. **Основные секции ELF-файла:**
   - **`.text`:** Содержит машинный код программы.
   - **`.data`:** Инициализированные глобальные переменные.
   - **`.bss`:** Неинициализированные переменные.
   - **`.rodata`:** Константы и строковые литералы.

Пример визуализации:

| **Секция** | **Назначение**                      |
|------------|-------------------------------------|
| `.text`    | Машинный код программы.             |
| `.data`    | Инициализированные глобальные данные.|
| `.bss`     | Неинициализированные данные.        |
| `.rodata`  | Константы (например, строки).       |


#### **Программные библиотеки**

Программные библиотеки содержат функции и ресурсы, которые могут быть использованы разными процессами.

##### **Типы библиотек**

1. **Статические библиотеки (.a):**
   - Код библиотеки компонуется в исполняемый файл на этапе компиляции.
   - Недостаток: увеличивает размер исполняемого файла.

2. **Динамические библиотеки (.so в Linux, .dll в Windows):**
   - Загрузка выполняется во время выполнения программы.
   - Преимущество: уменьшение размера исполняемого файла и экономия памяти за счёт совместного использования библиотек между процессами.
*подробнее о них написано ниже*

### **Отображение в память процесса**

Операционная система загружает исполняемые файлы и библиотеки в память процесса, организуя их в виде сегментов.

**Основные сегменты памяти:**

| **Сегмент** | **Назначение**                           |
|-------------|------------------------------------------|
| **Text**    | Машинный код программы.                  |
| **Data**    | Инициализированные глобальные переменные.|
| **BSS**     | Неинициализированные переменные.         |
| **Heap**    | Динамически выделяемая память.           |
| **Stack**   | Локальные переменные и вызовы функций.   |

 ***Как это работает?***
1. **Сегменты ELF-файла отображаются в память:**
   - `.text` — только для чтения и выполнения.
   - `.data` — для чтения и записи.
   - `.bss` — память инициализируется нулями.

2. **Механизм `mmap`:**
   - Операционная система использует системный вызов `mmap()` для отображения файлов в память.



### **Загрузка исполняемого файла в память**

##### **Системный вызов `execve()`**

`execve()` используется для загрузки нового исполняемого файла в память текущего процесса.

- **Синтаксис:**
  ```c
  int execve(const char *pathname, char *const argv[], char *const envp[]);
  ```
  - `pathname`: Путь к исполняемому файлу.
  - `argv`: Аргументы командной строки.
  - `envp`: Переменные окружения.

- **Пример:**
  ```c
  #include <unistd.h>
  #include <stdio.h>

  int main() {
      char *args[] = {"/bin/ls", "-l", NULL};
      execve("/bin/ls", args, NULL);

      // Если execve завершился ошибкой
      perror("execve failed");
      return 1;
  }
  ```

***Процесс загрузки:***
1. Операционная система завершает выполнение текущего кода процесса.
2. Загружает ELF-файл, анализируя заголовки.
3. Отображает сегменты в память с помощью `mmap`.
4. Устанавливает точку входа и передаёт управление программе.


***Пример работы с `mmap`***
```c
#include <sys/mman.h>
#include <fcntl.h>
#include <unistd.h>
#include <stdio.h>

int main() {
    int fd = open("example.bin", O_RDONLY);
    if (fd == -1) {
        perror("Ошибка открытия файла");
        return 1;
    }

    void *mapped = mmap(NULL, 4096, PROT_READ, MAP_PRIVATE, fd, 0);
    if (mapped == MAP_FAILED) {
        perror("Ошибка mmap");
        return 1;
    }

    printf("Файл отображён в память по адресу %p\n", mapped);
    munmap(mapped, 4096);
    close(fd);
    return 0;
}
```


###### **Заключение**
1. Исполняемые файлы содержат инструкции и данные, организованные в секции и сегменты, которые операционная система отображает в память.
2. Программные библиотеки бывают статическими и динамическими, причём последние позволяют экономить память.
3. Механизмы `execve` и `mmap` играют ключевую роль в загрузке и отображении файлов в память процесса.

---
### Пример ELF-файла и его структура

##### 1. Создание простого примера программы на C

```c
#include <stdio.h>

int main() {
    printf("Hello, ELF!\n");
    return 0;
}
```

Сохраним этот файл как `example.c`.

##### 2. Компиляция программы в ELF-файл

Используем GCC для компиляции:

```bash
gcc -o example example.c
```

- Это создаст исполняемый файл `example`, который будет в формате ELF (на системах Linux).


##### 3. Анализ структуры ELF-файла

Для анализа ELF-файлов используем утилиту `readelf`. Вводим команду:

```bash
readelf -a example
```


###### Пример вывода и объяснение основных частей ELF-файла

**Заголовок ELF**

```plaintext
ELF Header:
  Magic:   7f 45 4c 46 02 01 01 03 00 00 00 00 00 00 00 00
  Class:                             ELF64
  Data:                              2's complement, little endian
  Version:                           1 (current)
  OS/ABI:                            UNIX - System V
  ABI Version:                       0
  Type:                              EXEC (Executable file)
  Machine:                           Advanced Micro Devices X86-64
  Version:                           0x1
  Entry point address:               0x401000
  Start of program headers:          64 (bytes into file)
  Start of section headers:          952 (bytes into file)
  Flags:                             0x0
  Size of this header:               64 (bytes)
  Size of program headers:           56 (bytes)
  Number of program headers:         8
  Size of section headers:           64 (bytes)
  Number of section headers:         29
  Section header string table index: 28
```
- **Magic:** Указывает, что это ELF-файл (первые 4 байта: `7f 45 4c 46`).
- **Class:** Формат ELF (ELF64 для 64-битных систем).
- **Entry point address:** Адрес точки входа (где начинается выполнение программы).
- **Type:** Тип файла (`EXEC` означает исполняемый файл).
- **Machine:** Архитектура процессора (x86-64 в данном случае).



**Програмные заголовки (Program Headers)**
```plaintext
Program Headers:
  Type           Offset   VirtAddr           PhysAddr           FileSiz  MemSiz   Flg Align
  LOAD           0x000000 0x0000000000401000 0x0000000000401000 0x000a60 0x000a60 R E 0x200000
  LOAD           0x000a60 0x0000000000402a60 0x0000000000402a60 0x000238 0x000238 R   0x200000
  LOAD           0x000c98 0x0000000000404c98 0x0000000000404c98 0x00004c 0x000050 RW  0x200000
  LOAD           0x000ce8 0x0000000000600ce8 0x0000000000600ce8 0x000010 0x000010 RW  0x200000
```
- **Type:** Тип сегмента (`LOAD` означает, что сегмент нужно загрузить в память).
- **Offset:** Смещение сегмента в файле.
- **VirtAddr:** Виртуальный адрес в памяти, куда нужно отобразить сегмент.
- **Flg:** Права доступа (R — чтение, W — запись, E — выполнение).


**Секции (Sections)**
```plaintext
Section Headers:
  [Nr] Name              Type            Address          Off    Size   ES Flg Lk Inf Al
  [ 0]                   NULL            0000000000000000 000000 000000 00      0   0  0
  [ 1] .interp           PROGBITS        0000000000400238 000238 00001c 00   A  0   0  1
  [ 2] .note.ABI-tag     NOTE            0000000000400254 000254 000020 00   A  0   0  4
  [ 3] .gnu.hash         GNU_HASH        0000000000400278 000278 000024 00   A  4   0  8
  [ 4] .dynsym           DYNSYM          00000000004002a0 0002a0 0000c0 18   A  5   1  8
  [ 5] .dynstr           STRTAB          0000000000400360 000360 000087 00   A  0   0  1
  [ 6] .text             PROGBITS        0000000000401000 001000 0005c0 00  AX  0   0 16
  [ 7] .data             PROGBITS        0000000000404c98 004c98 000050 00  WA  0   0 16
```
- **`.interp`:** Указывает путь к динамическому компоновщику (`/lib64/ld-linux-x86-64.so.2`).
- **`.text`:** Секция с машинным кодом (инструкциями программы).
- **`.data`:** Инициализированные данные (глобальные переменные).
- **`.bss`:** Неинициализированные данные.



##### 4. Загрузка ELF-файла в память

Операционная система использует информацию из ELF-заголовка и программных заголовков, чтобы загрузить файл в память. Основные этапы:
1. **Чтение ELF-заголовка.**
2. **Отображение сегментов `LOAD` в память с помощью `mmap()`.**
3. **Установка точки входа и передача управления программе.**



##### 5. Вывод программы

Запустите ELF-файл:
```bash
./example
```

**Вывод:**
```
Hello, ELF!
```



### Типы библиотек

##### Статическая линковка

- **Включение кода:** Код библиотеки копируется в исполняемый файл во время сборки.
- **Размер исполняемого файла:** Увеличивается, так как код библиотеки включён в файл.
- **Зависимость от внешних файлов:** Программа самодостаточна, библиотека не требуется во время выполнения.
- **Обновление библиотеки:** Для использования новой версии требуется перекомпиляция программы.

Пример:
1. Создание статической библиотеки:
   ```bash
   gcc -c libexample.c -o libexample.o
   ar rcs libexample.a libexample.o
   ```
2. Компиляция программы:
   ```bash
   gcc -o program main.c libexample.a
   ```

##### Динамическая линковка

- **Включение кода:** Код библиотеки загружается в рантайме, а не копируется в файл.
- **Размер исполняемого файла:** Меньше, так как библиотека подключается отдельно.
- **Зависимость от внешних файлов:** Программа требует наличие библиотеки при запуске.
- **Обновление библиотеки:** Новая версия библиотеки может быть использована без перекомпиляции программы.

Пример:
1. Создание динамической библиотеки:
   ```bash
   gcc -fPIC -c libexample.c -o libexample.o
   gcc -shared -o libexample.so libexample.o
   ```
2. Компиляция программы:
   ```bash
   gcc -o program main.c -L. -lexample
   ```
3. Указание пути к библиотеке:
   ```bash
   export LD_LIBRARY_PATH=.:$LD_LIBRARY_PATH
   ./program
   ```

***Сравнение статической и динамической линковки:***

| **Характеристика**       | **Статическая линковка**                     | **Динамическая линковка**                      |
|--------------------------|-----------------------------------------------|-----------------------------------------------|
| **Включение кода**        | Код библиотеки копируется в исполняемый файл | Код библиотеки загружается в рантайме         |
| **Размер исполняемого файла** | Больше                                    | Меньше                                        |
| **Зависимость от файлов** | Независим (самодостаточен)                   | Требует наличия библиотеки при запуске        |
| **Обновление библиотеки** | Требуется перекомпиляция программы           | Новая версия библиотеки применяется сразу     |

**НО** тут всё написано так как-будто у статической только недостатки, а у динамического только преимущества,
а ведь если ты динамически линкуешься к какой-то библиотеке, компилируешь программу, то отправляешь её пользователям, чтобы они могли использовать, им нужно будет установить эту же библиотеку на свою машину, причём совместимую версию. А таких библиотек бывает очень много, если хотя бы одна будет слишком старая/новая, или её не будет у пользователя, у тебя нихуя работать не может. А у каждого пользователя своя какая-то отбитая система, и что-то совершенно разное может сломаться. А если все библетеки прилинкованы статически, то можно просто скомпилировать, отправить, и у всех всё будет работать независимо от того, что у них ещё есть или нету на компе.

---

### Этапы компиляции

Компиляция программы на C включает несколько последовательных этапов:

##### 1. **Предобработка (Preprocessing)**
   - Обрабатываются директивы препроцессора (например, `#include`, `#define`).
   - Удаляются комментарии и добавляются заголовочные файлы.
   - **Инструмент:** `cpp` (C Preprocessor).

   Пример команды:
   ```bash
   gcc -E example.c -o example.i
   ```
   - Результат: файл `example.i` содержит код на C после обработки директив.

##### 2. **Компиляция (Compilation)**
   - Код на C (`example.i`) переводится в ассемблерный код.
   - **Инструмент:** `cc1` (C Compiler).

   Пример команды:
   ```bash
   gcc -S example.i -o example.s
   ```
   - Результат: файл `example.s` содержит ассемблерный код.

##### 3. **Ассемблирование (Assembly)**
   - Ассемблерный код (`example.s`) преобразуется в объектный файл (машинный код).
   - **Инструмент:** `as` (Assembler).

   Пример команды:
   ```bash
   gcc -c example.s -o example.o
   ```
   - Результат: файл `example.o` — объектный файл.

##### 4. **Компоновка (Linking)**
   - Объектные файлы и библиотеки объединяются в исполняемый файл.
   - **Инструмент:** `ld` (Linker).

   Пример команды:
   ```bash
   gcc example.o -o example
   ```
   - Результат: файл `example` — готовый исполняемый файл.


###### Итог
Каждый этап компиляции отвечает за свою часть преобразования исходного кода в готовый исполняемый файл. Это позволяет детально контролировать процесс разработки и искать ошибки на каждом этапе.

