Операционные системы выполняют две основные функции: предоставление абстракций для пользовательских программ и управление ресурсами компьютера. Взаимодействие между пользовательскими программами и операционной системой, как правило, связано с первым аспектом: например, создание, запись, чтение и удаление файлов. Управление ресурсами в основном прозрачно для пользователей и выполняется автоматически.

Таким образом, интерфейс между пользовательскими программами и операционной системой в основном сосредоточен на работе с абстракциями. Чтобы действительно понять, что делают операционные системы, необходимо внимательно изучить этот интерфейс. Набор системных вызовов, доступных в интерфейсе, варьируется в зависимости от операционной системы (хотя базовые концепции, как правило, схожи).

Важно помнить: компьютер с одним процессором может выполнять только одну инструкцию за раз. Если процесс выполняет пользовательскую программу в пользовательском режиме и нуждается в системной службе (например, чтении данных из файла), он должен выполнить инструкцию `trap`, чтобы передать управление операционной системе. ОС выясняет, что нужно вызывающему процессу, анализируя параметры, выполняет системный вызов и возвращает управление на инструкцию, следующую за вызовом. Таким образом, системный вызов похож на особый вид вызова процедуры, но системные вызовы входят в ядро, а обычные вызовы процедур — нет.

> Библиотечные процедуры - это например `sqrt` из `math.h`. То есть это функция или подпрограмма, которая предоставляется библиотекой программного обеспечения. Такие процедуры используются для выполнения часто встречающихся задач, что позволяет программистам избегать написания собственного кода для этих задач. Библиотечные процедуры, как правило, входят в состав стандартных библиотек языка программирования (например, `math.h` или `stdlib.h` в C). 

![[Drawing 2025-01-21 23.05.14.excalidraw]]
Операционные системы разделяют выполнение программ на два режима: **пользовательский режим** (user mode) и **режим ядра** (kernel mode). В пользовательском режиме приложение имеет ограниченный доступ к аппаратным ресурсам. Для выполнения привилегированных операций, таких как работа с файлами или управление памятью, используется переход в режим ядра через **системные вызовы**.

##### Различие: системные вызовы и системные функции

- **Системный вызов** — это низкоуровневый механизм, который переключает процессор в режим ядра для выполнения операций (например, `sys_read`, `sys_write`).
- **Системная функция** — это высокоуровневая обертка над системным вызовом, предоставляющая более удобный интерфейс для программиста.

Пример:

- `read()` — системная функция из библиотеки C.
- `sys_read` — фактический системный вызов, который выполняется в ядре.

После всей этой информации легко перепутать библиотечные процедуры с системными функциями. Но они не то же самое, хотя между ними есть связь. Вот таблица, чтобы всё стало ясно.

| **Характеристика**   | **Библиотечная процедура**                                                                          | **Системная функция**                                                         |
| -------------------- | --------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------- |
| **Уровень работы**   | Работает на уровне пользовательского пространства.                                                  | Взаимодействует с ядром операционной системы.                                 |
| **Цель**             | Предоставляет удобный интерфейс для выполнения часто используемых операций.                         | Является оберткой над системным вызовом, взаимодействует с ядром.             |
| **Связь с ядром ОС** | Не всегда взаимодействует с ядром; может выполнять операции только в пользовательском пространстве. | Всегда вызывает системные вызовы, которые переключают процессор в режим ядра. |
| **Примеры**          | `printf`, `strlen`, `malloc`, `strcpy`                                                              | `open`, `read`, `write`, `fork`, `execve`                                     |
| **Место в системе**  | Часть стандартной библиотеки (`libc`, `libm`, и т.д.).                                              | Часть интерфейса операционной системы (POSIX, Windows API).                   |
![[Drawing 2025-01-21 23.04.18.excalidraw]]

## Шаги перехода из пользовательского режима в режим ядра
![[Pasted image 20250121230541.png]]
1. **Инициация системного вызова**
   - Программа вызывает библиотечную функцию, например `read`, `write` или `open`. Эти функции предоставляют интерфейс для взаимодействия с операционной системой.
   - Пример:
     ```c
     int fd = open("example.txt", O_RDONLY);
     ```

2. **Подготовка параметров**
   - Параметры системного вызова передаются через:
     - Регистры процессора (в большинстве современных архитектур).
     - Стек (в некоторых архитектурах или старых подходах).
   - Например, для вызова `read` передаются:
     - **Идентификатор файла (fd)**.
     - **Адрес буфера** для записи данных.
     - **Количество байт для чтения (nbytes)**.

3. **Выполнение инструкции `TRAP` или аналогичной**
   - Специальная команда процессора (например, `syscall` в x86-64 или `svc` в ARM) вызывает прерывание, известное как **software interrupt** или **trap**.
   - Это:
     - Прекращает выполнение программы в пользовательском режиме.
     - Переключает процессор в режим ядра.
     - Передает управление операционной системе по заранее определенному адресу.

4. **Обработка вызова в режиме ядра**
   - Ядро проверяет параметры вызова и идентификатор системного вызова.
   - Используется таблица системных вызовов, где каждому вызову соответствует обработчик.
   - Ядро выполняет запрошенную операцию.

5. **Возврат в пользовательский режим**
   - После завершения системного вызова ядро возвращает управление в библиотечную функцию.
   - Результат операции передается вызывающей программе (например, число прочитанных байт или код ошибки).

---

Пример механизма в Linux (x86-64)

1. **Вызов библиотечной функции**:
```c
   ssize_t bytes = read(fd, buffer, nbytes);
```
- **Подготовка параметров**:
    
    - Помещение идентификатора системного вызова в регистр `RAX`.
    - Помещение параметров (`fd`, `buffer`, `nbytes`) в регистры `RDI`, `RSI`, `RDX`.
- **Выполнение инструкции `syscall`**:
```assembly
mov rax, 0          ; Код системного вызова read
mov rdi, fd         ; Первый параметр: дескриптор файла
mov rsi, buffer     ; Второй параметр: адрес буфера
mov rdx, nbytes     ; Третий параметр: количество байт
syscall             ; Переход в режим ядра

```
- **Обработка ядром**:
    
    - Ядро использует таблицу системных вызовов для вызова обработчика.
    - Результат сохраняется в регистре `RAX`.
- **Возврат в пользовательский режим**:
    
    - Управление возвращается библиотечной функции.
    - Результат доступен в переменной программы.

##### Важные аспекты

1. **Безопасность**:
    
    - Переход в режим ядра возможен только через строго контролируемый интерфейс (системные вызовы).
    - Это предотвращает случайное или злонамеренное вмешательство в работу системы.
2. **Производительность**:
    
    - Переход между режимами (user → kernel → user) — дорогостоящая операция, поскольку требует переключения контекста. Поэтому минимизация вызовов в режим ядра важна.
3. **Обработка ошибок**:
    
    - Если вызов завершился с ошибкой, ядро возвращает отрицательное значение (например, `-1`), а библиотечная функция устанавливает код ошибки в глобальную переменную `errno`.

Если системный вызов блокирует вызывающий процесс (например, при ожидании ввода с клавиатуры), операционная система переключает выполнение на другой процесс. Когда ввод становится доступным, выполнение возвращается к вызвавшему процессу.

POSIX включает около 100 процедурных вызовов, из которых многие являются системными. Эти вызовы включают создание и завершение процессов, работу с файлами и директориями, а также ввод-вывод. Хотя POSIX определяет требования к процедурам, он не указывает, являются ли они системными вызовами или библиотечными.

> **POSIX** (_Portable Operating System Interface_) — это набор стандартов, определяющих интерфейс между операционной системой и программными приложениями. Эти стандарты были разработаны Институтом инженеров электротехники и электроники (**IEEE**) для обеспечения переносимости программ между различными операционными системами.
> 


# Системные вызовы для управления процессами (Process management)

Первая группа системных вызовов, связанная с управлением процессами, описана ниже. Основным примером является вызов **fork**, который является единственным способом создания нового процесса в POSIX. Этот вызов создает точную копию оригинального процесса, включая файловые дескрипторы, регистры и другие ресурсы.

После вызова **fork** оригинальный процесс (родитель) и созданный процесс (дочерний) продолжают выполнение независимо друг от друга. Все переменные на момент вызова имеют одинаковые значения, но изменения в данных одного процесса не влияют на другой, так как данные копируются. Исключение составляет текст программы, который является неизменяемым и используется совместно.


### Вызов `fork`

- **Возвращаемое значение**:
  - **0** в дочернем процессе.
  - **PID дочернего процесса** в родительском процессе.
- С помощью возвращаемого значения процессы определяют, кто из них родитель, а кто — потомок.

## Основные системные вызовы для управления процессами

| Вызов                                   | Описание                                                                                                                                                                                     |
| --------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `pid = fork()`                          | Создает дочерний процесс, идентичный родительскому.                                                                                                                                          |
| `pid = waitpid(pid, &statloc, options)` | Ожидает завершения дочернего процесса.                                                                                                                                                       |
| `s = execve(name, argv, environp)`      | Процесс перестает исполнять свой код и данные и начинает выполнять другую программу, полностью заменяя содержимое своей памяти (кроме идентификатора процесса и некоторых системных данных). |
| `exit(status)`                          | Завершает выполнение процесса с возвращением статуса.                                                                                                                                        |


### Как работает `fork` и взаимодействие с `execve`

***Пример работы оболочки (shell)***

1. Оболочка считывает команду от пользователя.
2. Создает новый процесс с помощью **fork**.
3. Родительский процесс ожидает завершения дочернего с помощью **waitpid**.
4. Дочерний процесс выполняет команду с помощью **execve**.

Пример кода оболочки:
```c
#define TRUE 1

while (TRUE) { 
    type_prompt();                     // Отобразить приглашение для ввода
    read_command(command, parameters); // Считать команду и параметры

    if (fork() != 0) {                 // Родительский процесс
        waitpid(-1, &status, 0);       // Ожидание завершения дочернего процесса
    } else {                           // Дочерний процесс
        execve(command, parameters, 0); // Выполнение команды
    }
}
```

Общий случай вызова `execve`:

**`execve`** — системный вызов POSIX, позволяющий заменить текущий образ процесса другим. Он принимает три параметра:
1. **Имя файла**: путь к исполняемому файлу.
2. **Указатель на массив аргументов**: передает параметры командной строки.
3. **Указатель на массив окружения**: передает переменные окружения.

Различные библиотечные функции, такие как `execl`, `execv`, `execle`, упрощают вызов, позволяя задавать параметры разными способами.

Пример команды: `cp file1 file2`
Для команды копирования:
1. Оболочка вызывает `fork`, чтобы создать дочерний процесс.
2. Дочерний процесс вызывает `execve`, чтобы выполнить программу `cp`, передав аргументы:
   - `argv[0]` = `"cp"`
   - `argv[1]` = `"file1"`
   - `argv[2]` = `"file2"`

Аргументы в функции `main`:
```c
main(argc, argv, envp)
```
- **`argc`**: количество аргументов, включая имя программы.
- **`argv`**: массив строк, содержащий аргументы командной строки.
- **`envp`**: массив строк, представляющий переменные окружения.

---

Процессы UNIX делят память на три сегмента:

1. **Текстовый сегмент**: неизменяемый код программы.
2. **Сегмент данных**: переменные программы.
3. **Сегмент стека**: локальные переменные и вызовы функций.


- **Данные**: могут расширяться вызовом `brk` (не стандартизирован в POSIX, вместо него используется `malloc`).
- **Стек**: растет автоматически, заполняя промежуток между сегментами.

---

# Системные вызовы для работы с файлами

Основные операции:

Для чтения и записи файлов необходимо:

1. **Открыть файл**:
    
    - Указание имени файла и режима (`O_RDONLY`, `O_WRONLY`, `O_RDWR`).
    - Для создания файла используется параметр `O_CREAT`.
2. **Работа с файловым дескриптором**:
    
    - Чтение/запись осуществляется через вызовы `read` и `write`.
3. **Закрытие файла**:
    
    - `close` освобождает дескриптор для повторного использования.

### Системные вызовы для управления файлами

|Вызов|Описание|
|---|---|
|`fd = open(file, how, ...)`|Открыть файл для чтения, записи или обоих операций.|
|`s = close(fd)`|Закрыть файл.|
|`n = read(fd, buffer, nbytes)`|Прочитать данные из файла в буфер.|
|`n = write(fd, buffer, nbytes)`|Записать данные из буфера в файл.|
|`position = lseek(fd, offset, whence)`|Изменить указатель текущей позиции в файле.|

---

### Управление файловой позицией: lseek

**`lseek`** позволяет изменять текущую позицию чтения/записи в файле.

Параметры:
1. **Файловый дескриптор**: идентификатор открытого файла.
2. **Смещение**: позиция в файле.
3. **Базис**:
    - Начало файла.
    - Текущая позиция.
    - Конец файла.

Возвращаемое значение:
Абсолютная позиция в файле после изменения указателя.

