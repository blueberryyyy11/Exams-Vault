**Сигналы, обработка сигналов. Примеры применения сигналов.**

### Что такое сигналы

Сигналы в Unix-подобных операционных системах — это механизмы межпроцессного взаимодействия, позволяющие ОС и процессам обмениваться асинхронными уведомлениями. Сигналы используются для информирования процесса о событиях, таких как завершение работы, ошибки или запросы управления.

### Основные характеристики сигналов

1. **Асинхронность:** Сигналы могут быть отправлены в любое время, независимо от состояния процесса.
2. **Предопределённый набор сигналов:** Каждый сигнал имеет уникальный идентификатор (номер), определённый системой.
3. **Обработчики сигналов:** Процессы могут обрабатывать определённые сигналы с помощью пользовательских функций.
4. **Действие по умолчанию:** Если для сигнала не указан обработчик, ОС выполняет действие по умолчанию (например, завершение процесса).


### Как отправить сигналы в процесс

#### 1. Отправка сигналов из терминала

##### Команда `kill`
Команда `kill` отправляет сигнал процессу с указанным PID.

- **Синтаксис:**
  ```bash
  kill -<номер_сигнала> <PID>
  ```

- **Примеры:**
  - Отправить сигнал `SIGTERM` (по умолчанию) процессу с PID 1234:
    ```bash
    kill 1234
    ```
  - Отправить сигнал `SIGKILL` (немедленное завершение):
    ```bash
    kill -9 1234
    ```
  - Отправить сигнал `SIGUSR1` (пользовательский):
    ```bash
    kill -10 1234
    ```


##### Команда `killall`
Команда `killall` завершает все процессы с указанным именем.

- **Синтаксис:**
  ```bash
  killall -<номер_сигнала> <имя_процесса>
  ```

- **Пример:**
  Завершить все процессы с именем `example_program`:
  ```bash
  killall -15 example_program
  ```


##### Команда `pkill`
Команда `pkill` отправляет сигнал процессам по имени или по шаблону.

- **Синтаксис:**
  ```bash
  pkill -<номер_сигнала> <шаблон>
  ```

- **Пример:**
  Отправить сигнал `SIGUSR1` всем процессам, содержащим `example` в названии:
  ```bash
  pkill -USR1 example
  ```


##### Использование команды `htop`
1. Запустите утилиту `htop`:
   ```bash
   htop
   ```
2. Найдите процесс, выделите его с помощью клавиш-стрелок.
3. Нажмите **F9** (Kill) и выберите сигнал (например, `SIGTERM` или `SIGKILL`).


#### 2. Отправка сигналов программно

##### Функция `kill()`
Системный вызов `kill()` отправляет сигнал процессу с указанным PID.

- **Синтаксис:**
  ```c
  int kill(pid_t pid, int signal);
  ```
  - `pid`: PID процесса, которому отправляется сигнал.
  - `signal`: Номер или имя сигнала.

- **Пример:**
  ```c
  #include <signal.h>
  #include <stdio.h>
  #include <unistd.h>

  int main() {
      pid_t pid = getpid(); // Получаем PID текущего процесса
      printf("Отправляем SIGTERM самому себе...\n");
      kill(pid, SIGTERM);
      return 0;
  }
  ```

---

##### Функция `raise()`
Функция `raise()` отправляет сигнал текущему процессу.

- **Синтаксис:**
  ```c
  int raise(int signal);
  ```

- **Пример:**
  ```c
  #include <signal.h>
  #include <stdio.h>

  int main() {
      printf("Отправляем SIGUSR1 самому себе...\n");
      raise(SIGUSR1);
      return 0;
  }
  ```

---

##### Функция `pthread_kill()`
Если программа использует потоки, `pthread_kill()` позволяет отправить сигнал конкретному потоку.

- **Синтаксис:**
  ```c
  int pthread_kill(pthread_t thread, int signal);
  ```

- **Пример:**
  ```c
  #include <pthread.h>
  #include <signal.h>
  #include <stdio.h>
  #include <unistd.h>

  void *thread_func(void *arg) {
      printf("Поток ждёт сигнал...\n");
      pause(); // Ждём сигнал
      return NULL;
  }

  int main() {
      pthread_t thread;
      pthread_create(&thread, NULL, thread_func, NULL);
      sleep(1);

      printf("Отправляем SIGUSR1 потоку...\n");
      pthread_kill(thread, SIGUSR1);
      pthread_join(thread, NULL);
      return 0;
  }
  ```

### Итог

Сигналы можно отправлять несколькими способами:
1. **Через терминал:** Используйте команды `kill`, `pkill`, `killall`, `htop`.
2. **Программно:** Вызовите функции `kill`, `raise` или `pthread_kill`.
3. **С помощью других утилит:** Например, с использованием `ps` для поиска PID.

---
## Основные системные вызовы для работы с сигналами

##### 1. **`kill(pid, signal)`** — Отправляет сигнал процессу с указанным PID.
   Отправляет сигнал другому процессу по его идентификатору (PID).
**Пример: Завершение процесса с помощью SIGTERM**
```c
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

int main() {
    pid_t pid;
    printf("Введите PID процесса, который хотите завершить: ");
    scanf("%d", &pid);

    if (kill(pid, SIGTERM) == 0) {
        printf("Сигнал SIGTERM отправлен процессу %d.\n", pid);
    } else {
        perror("Ошибка при отправке сигнала");
    }

    return 0;
}

```

##### 2. **`raise(signal)`** — Отправляет сигнал текущему процессу.
   Этот вызов позволяет процессу отправить сигнал самому себе.

**Пример: Завершение программы с SIGINT**
```c
#include <signal.h>
#include <stdio.h>
#include <unistd.h>

int main() {
    printf("Сейчас отправим сигнал SIGINT самому себе...\n");
    raise(SIGINT);
    printf("Эта строка не выполнится, так как процесс завершится.\n");
    return 0;
}
```

##### 3. **`signal(signal, handler)`** — Устанавливает обработчик для указанного сигнала.
   Позволяет указать функцию, которая будет выполняться при получении сигнала.

**Пример: Обработка SIGINT**
```c
#include <signal.h>
#include <stdio.h>
#include <unistd.h>

void handle_sigint(int sig) {
    printf("Получен сигнал SIGINT (%d). Игнорируем завершение.\n", sig);
}

int main() {
    signal(SIGINT, handle_sigint);
    printf("Нажмите Ctrl+C для отправки SIGINT.\n");

    while (1) {
        sleep(1);
        printf("Работа программы...\n");
    }

    return 0;
}

```

##### 4. **`sigaction(signal, action, old_action)`** — Более гибкий способ настройки обработчиков сигналов.
   `sigaction` предоставляет более мощный способ обработки сигналов.

**Пример: Обработка SIGUSR1 с использованием `sigaction`**
```c
#include <signal.h>
#include <stdio.h>
#include <unistd.h>

void handle_sigusr1(int sig) {
    printf("Получен пользовательский сигнал SIGUSR1 (%d).\n", sig);
}

int main() {
    struct sigaction sa;
    sa.sa_handler = handle_sigusr1; // Устанавливаем обработчик
    sa.sa_flags = 0; // Дополнительные опции

    sigaction(SIGUSR1, &sa, NULL);

    printf("Отправьте сигнал SIGUSR1 этому процессу (PID: %d).\n", getpid());

    while (1) {
        pause(); // Ждем сигнал
    }

    return 0;
}
```
- `struct sigaction` — структура, которая задаёт обработчик сигнала и дополнительные параметры:
        - `sa_handler` — указатель на функцию-обработчик.
        - `sa_flags` — дополнительные флаги для настройки поведения.
    - `sigaction(SIGUSR1, &sa, NULL)`:
        - Привязывает функцию `handle_sigusr1` как обработчик для сигнала `SIGUSR1`.
        - Третий параметр (`NULL`) указывает, что старые настройки не нужно сохранять.
          
##### 5. **`pause()`** — Приостанавливает выполнение процесса до получения сигнала.
   Приостанавливает выполнение до тех пор, пока процесс не получит сигнал.

**Пример: Использование pause для ожидания SIGINT**
```c
#include <signal.h>
#include <stdio.h>
#include <unistd.h>

void handle_sigint(int sig) {
    printf("Получен SIGINT (%d). Продолжаем работу.\n", sig);
}

int main() {
    signal(SIGINT, handle_sigint);

    printf("Процесс приостановлен. Нажмите Ctrl+C для отправки SIGINT.\n");
    pause();

    printf("Процесс завершен после получения сигнала.\n");
    return 0;
}

```

##### 6. **`alarm(seconds)`** — Устанавливает таймер, после истечения которого процессу отправляется сигнал `SIGALRM`.

**Пример: Таймер с использованием alarm**
```c
#include <signal.h>
#include <stdio.h>
#include <unistd.h>

void handle_sigalrm(int sig) {
    printf("Таймер истёк! Получен сигнал SIGALRM (%d).\n", sig);
}

int main() {
    signal(SIGALRM, handle_sigalrm);

    printf("Устанавливаем таймер на 5 секунд...\n");
    alarm(5);

    printf("Ждем сигнала.\n");
    pause();

    printf("Таймер завершился, программа продолжает работу.\n");
    return 0;
}

```
1. **Программа стартует:**
    
    - Устанавливается обработчик для сигнала `SIGALRM`.
    - Таймер на 5 секунд запускается с помощью `alarm(5)`.
2. **Ожидание:**
    
    - Программа приостанавливается функцией `pause()` до получения сигнала.
3. **Срабатывание таймера:**
    
    - Через 5 секунд срабатывает `alarm`, отправляя процессу сигнал `SIGALRM`.
4. **Обработка сигнала:**
    
    - Ядро вызывает функцию `handle_sigalrm`, которая выводит сообщение о том, что таймер истёк.
5. **Продолжение работы:**
    
    - После обработки сигнала программа продолжает выполнение и завершает работу.
---

## Распространённые сигналы и их действия

|**Сигнал**|**Номер**|**Действие по умолчанию**|**Описание**|
|---|---|---|---|
|`SIGINT`|2|Завершение процесса|Прерывание работы (Ctrl + C).|
|`SIGTERM`|15|Завершение процесса|Просьба завершить процесс.|
|`SIGKILL`|9|Немедленное завершение процесса|Принудительное завершение (не игнорируется).|
|`SIGSTOP`|19|Приостановка процесса|Остановка выполнения процесса.|
|`SIGCONT`|18|Продолжение выполнения процесса|Возобновление приостановленного процесса.|
|`SIGHUP`|1|Завершение или перезапуск|Уведомление об отключении терминала.|
|`SIGALRM`|14|Завершение процесса|Таймер истёк (используется `alarm`).|

### **Сигналы: `SIGKILL`, `SIGTERM`, `SIGINT`, `SIGSEGV`, `SIGUSR1`, `SIGUSR2`**

#### **1. `SIGKILL` (номер: 9)**

- **Описание:**  
    Сигнал для немедленного завершения процесса.  
    Его невозможно перехватить, игнорировать или обработать, так как это низкоуровневый системный механизм, используемый для принудительного завершения процесса.
    
- **Применение:**  
    Когда процесс не реагирует на обычные сигналы (`SIGTERM`), используется `SIGKILL`.
    
- **Пример:**  
    Завершение процесса с PID 1234:
```c
    kill -9 1234
```
    


#### **2. `SIGTERM` (номер: 15)**

- **Описание:**  
    Стандартный сигнал для завершения процесса.  
    Процесс может перехватить этот сигнал, выполнить финализирующие действия (например, сохранить данные) и завершиться корректно.
    
- **Применение:**  
    Используется для "мягкого" завершения процесса. Если процесс не реагирует, используют `SIGKILL`.
    
- **Пример:**  
    Завершение процесса:
 ```c
    kill 1234
```    
    
    
- **Пример с обработкой в программе:**
```c
#include <signal.h>
#include <stdio.h>
#include <unistd.h>

void handle_sigterm(int sig) {
    printf("Получен сигнал SIGTERM. Завершаем работу.\n");
    _exit(0);
}

int main() {
    signal(SIGTERM, handle_sigterm);
    while (1) {
        printf("Работаем...\n");
        sleep(1);
    }
    return 0;
}

```
- **Почему `_exit(0)`?** Эта функция завершает программу, пропуская очистку, например, закрытие файлов или освобождение ресурсов. Это полезно для мгновенного завершения после сигнала.

#### **Пример работы программы**

1. **Компиляция и запуск:**
    `gcc -o sigterm_example sigterm_example.c ./sigterm_example`
    
2. **Работа программы:**
    
    - Программа будет выводить каждую секунду:

        `Работаем...`
        
3. **Отправка сигнала `SIGTERM`:**
    
    - Найдите PID процесса:
        `ps aux | grep sigterm_example`
        
    - Отправьте сигнал `SIGTERM`:

        `kill -15 <PID>`
        
4. **Реакция программы:**
    
    - При получении `SIGTERM` программа вызовет обработчик `handle_sigterm` и выведет:
        
        `Получен сигнал SIGTERM. Завершаем работу.`
        
    - После этого программа завершит выполнение.


#### **3. `SIGINT` (номер: 2)**

- **Описание:**  
    Сигнал прерывания, отправляемый процессу, когда пользователь нажимает **Ctrl+C** в терминале.
    
- **Применение:**  
    Используется для безопасного прерывания процесса пользователем.
    
- **Пример обработки в программе:**
    
```c
#include <signal.h>
#include <stdio.h>
#include <unistd.h>

void handle_sigint(int sig) {
    printf("Получен сигнал SIGINT (%d). Выход.\n", sig);
    _exit(0);
}

int main() {
    signal(SIGINT, handle_sigint);
    while (1) {
        printf("Нажмите Ctrl+C для выхода.\n");
        sleep(1);
    }
    return 0;
}

```
 Бесконечный цикл `while(1)` выполняет программу до тех пор, пока её не прервёт сигнал.
    - `sleep(1)` приостанавливает выполнение программы на 1 секунду между итерациями, уменьшая нагрузку на процессор.
- **Что происходит при нажатии `Ctrl+C`:**
    
    - Когда пользователь нажимает `Ctrl+C`:
        1. Генерируется сигнал `SIGINT`.
        2. Программа вызывает функцию `handle_sigint`.
        3. В обработчике выводится сообщение и программа завершает выполнение.


#### **4. `SIGSEGV` (номер: 11)**

- **Описание:**  
    Сигнал сегментационной ошибки. Он возникает, когда программа пытается обратиться к недопустимой области памяти (например, чтение из несуществующего адреса).
    
- **Применение:**  
    Используется для диагностики ошибок памяти в программах.
    
- **Пример:** Сигнал будет сгенерирован автоматически, если выполнить недопустимую операцию:
    
```c
#include <stdio.h>

int main() {
    int *ptr = NULL;
    *ptr = 42; // Ошибка: обращение к нулевому указателю
    return 0;
}

```
### **Куда идёт сигнал?**

Когда программа совершает попытку обратиться к недопустимой области памяти (в данном случае по адресу `NULL`), ядро операционной системы обнаруживает нарушение защиты памяти и автоматически отправляет сигнал `SIGSEGV` текущему процессу (тому, который вызвал ошибку).

- **По умолчанию:** Если для сигнала `SIGSEGV` не установлен пользовательский обработчик, процесс немедленно завершится.
- **Действие по умолчанию:** Вывод сообщения об ошибке сегментации (например, `"Segmentation fault (core dumped)"`) и завершение программы.


#### **5. `SIGUSR1` и `SIGUSR2` (номера: 10 и 12)**

- **Описание:**  
    Пользовательские сигналы, зарезервированные для использования в программах. Они не имеют предопределённого поведения, и их можно использовать для произвольных целей.
    
- **Применение:**  
    Передача пользовательских уведомлений между процессами.
    
- **Пример обработки `SIGUSR1`:**
```c
#include <signal.h>
#include <stdio.h>
#include <unistd.h>

void handle_sigusr1(int sig) {
    printf("Получен пользовательский сигнал SIGUSR1 (%d).\n", sig);
}

int main() {
    signal(SIGUSR1, handle_sigusr1);
    printf("Отправьте сигнал SIGUSR1 этому процессу (PID: %d).\n", getpid());
    while (1) {
        pause();
    }
    return 0;
}

```
    
- **Отправка `SIGUSR1` из другого терминала:**
```bash
kill -10 <PID>
```
    
---

### Обработка сигналов

##### Установка обработчика сигналов

Для обработки сигналов процесс может установить собственную функцию-обработчик. Это позволяет выполнять произвольные действия при получении сигнала.

Пример установки обработчика для сигнала `SIGINT`:

```c
#include <stdio.h>
#include <signal.h>
#include <unistd.h>

void handle_sigint(int sig) {
    printf("Получен сигнал SIGINT (%d). Завершаем программу.\n", sig);
    _exit(0);
}

int main() {
    signal(SIGINT, handle_sigint);
    while (1) {
        printf("Работа программы. Нажмите Ctrl+C для выхода.\n");
        sleep(1);
    }
    return 0;
}
```

##### Блокировка сигналов

Процессы могут временно блокировать сигналы с использованием `sigprocmask`. Это полезно для предотвращения прерываний в критических секциях программы.

Пример блокировки:

```c
#include <signal.h>
#include <stdio.h>
#include <unistd.h>

int main() {
    sigset_t set;
    sigemptyset(&set);
    sigaddset(&set, SIGINT);

    // Блокируем SIGINT
    sigprocmask(SIG_BLOCK, &set, NULL);

    printf("SIGINT заблокирован. Нажмите Ctrl+C.\n");
    sleep(5);

    // Разблокируем SIGINT
    sigprocmask(SIG_UNBLOCK, &set, NULL);
    printf("SIGINT разблокирован.\n");

    while (1) {
        sleep(1);
    }
    return 0;
}
```

---

### Примеры применения сигналов

##### 1. **Управление процессами:**

- Завершение процесса с помощью `SIGTERM` или `SIGKILL`.
- Приостановка и возобновление выполнения процесса (`SIGSTOP`, `SIGCONT`).

##### 2. **Таймеры и будильники:**

- Использование `alarm()` для установки таймера с генерацией `SIGALRM`.

##### 3. **Перезапуск конфигурации сервисов:**

- Многие серверные приложения (например, Nginx, Apache) используют сигнал `SIGHUP` для перезапуска конфигурации без остановки работы.

##### 4. **Обработка ошибок:**

- Использование `SIGSEGV` для диагностики сегментационных ошибок (например, при неправильном доступе к памяти).

##### 5. **Межпроцессное взаимодействие:**

- Передача сигналов между процессами для синхронизации или уведомлений.
