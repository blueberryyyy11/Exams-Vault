# **Концепция потока. Различия и особенности потоков и процессов. Работы с потоками**

В какой-то момент процессы стали разрастаться до такой степени, что уже внутри процесса бывали такие моменты, когда процессор мог бы заниматься чем-то ещё, не обязательно переключаться на другой процесс, а заниматься чем-то ещё в рамках этого же процесса. И мы увидим, как треды справились с этой задачей.

Итак, с точки зрения операционной системы, на таком высоком абстрактном уровне у процесса есть два главных аспекта. Есть аспект владения. Тут речь идёт о ресурсах, которые в данный момент доступны процессу. Процесс без доступа к ресурсам не имеет смысла: процесс как минимум должен иметь доступ в какой-то момент к ресурсам центрального процессора, чтобы выполнять на нём собственные операции. Но чаще всего процесс имеет доступ к различным устройствам. Например, процесс выводит что-нибудь на экран, читает что-нибудь с диска или записывает что-нибудь в память и так далее.

И, как мы знаем, операционная система является неким модератором: она управляет распределением этих ресурсов, она даёт и отбирает доступ. Поэтому, с точки зрения операционной системы, процесс — это некоторый агент, который постоянно запрашивает разные ресурсы, и эти ресурсы нужно ему предоставить в таком количестве, чтобы этот процесс мог успешно выполниться.

Другой аспект — это планирование и исполнение. Это всё, что касается запуска процесса, его выполнения, завершения, переключений между процессами и так далее. Такие детали, как, например, приоритет, тоже относятся к этому аспекту процесса. Операционная система, как правило, относится к этим двум аспектам независимо друг от друга, то есть есть аспект владения, есть аспект ресурсов, есть аспект планирования, и они не должны в большинстве случаев влиять друг на друга. Решения, которые принимает операционная система, должны опираться на какой-то один изолированный набор параметров.

Итак, когда мы говорим о выполнении, то именно в этом аспекте имеет значение понятие треда или потока. Thread — это "нить". И это не совсем удачный, наверное, перевод, но в целом похожий. Если весь процесс — это ткань, то ткань состоит из большого количества этих нитей, и в этом смысле аналогия подходит.

Тред - это элемент выполнения процесса. Когда мы говорим о процессе и имеем в виду его аспект владения, называем это обычно задачей. Поэтому во многих операционных системах есть так называемые таск-менеджеры. Там вы можете увидеть все процессы, запущенные в данный момент в системе, и узнать, какие и в каком количестве ресурсы компьютера эти процессы используют.

Например, можно увидеть, сколько времени центрального процессора (в процентах) занимает какой-то процесс или сколько памяти «съедает» какой-нибудь браузер. В этом плане процессы представляются как задачи — задачи, которые исполняются в данный момент в операционной системе.

Что же такое тред? На самом деле, это очень очевидная и простая концепция. Тред — это поток выполнения внутри процесса. Самая простая аналогия: процесс — это ткань, а тред — это нить внутри этой ткани. Естественно, он не идентичен самому процессу, поэтому его и называют иным именем, но во многом тред похож на процесс.**Это наименьшая единица обработки с точки зрения операционной системы**.

Когда мы говорим о многопоточности (или multithreading на английском), мы имеем в виду способность платформы, приложения или виртуальной машины запускать несколько параллельных потоков в рамках одного процесса. На этой диаграмме можно увидеть разные подходы к созданию и поддержке тредов в операционной системе.
![[Drawing 2025-01-21 03.30.12.excalidraw]]
В верхнем левом углу, в прямоугольнике, вы видите синий квадрат, который означает процесс. Линия, состоящая из точек, символизирует тред. В этой ситуации у нас есть один процесс и один тред. Здесь показывается операционная система, которая поддерживает только один процесс в любой момент времени, причём этот процесс может иметь только один тред. Процесса без треда быть не может: как минимум один тред всегда существует в любом процессе — это его основной путь выполнения.

Пример такой операционной системы — старая версия MS-DOS. В такой системе можно было запустить только одну программу. Если вы хотели запустить другую, нужно было закрыть текущую. В текущей программе, запущенной в данный момент, был только один тред. Это по-настоящему однозадачная система.

Пример в верхнем правом углу диаграммы показывает другой случай. Здесь у нас также один процесс, но в этом процессе есть несколько тредов — в данном случае три, хотя их количество не принципиально. Эта архитектура немного лучше: у нас всё ещё только один процесс, но внутри этого процесса существуют подпроцессы (треды), которые выполняются виртуально одновременно.

Некоторые старые версии Unix могли поддерживать один процесс, но несколько потоков внутри него. Подход, изображённый в нижнем левом углу диаграммы, представляет несколько процессов, каждый из которых имеет один тред. Ну а то, что мы видим сегодня чаще всего в современных популярных операционных системах, — это то, что можно увидеть в нижнем правом углу: несколько процессов, каждый из которых имеет несколько тредов. Это наиболее эффективная конфигурация, поскольку она позволяет существовать нескольким сложным программам, которые могут запускаться одновременно и выполнять очень сложные задачи.

Когда мы говорим о потоках внутри процесса, то чаще всего мы видим всё то же самое, что можно наблюдать в процессах. У потока есть своё состояние, потому что, грубо говоря, поток — это своего рода процесс. В какой-то момент поток может быть приостановлен, если ему не удастся завершить свою работу за один раз. Это означает, что к нему нужно будет вернуться, его нужно будет перезапустить и восстановить, для чего требуется сохранить его состояние.

Также у потока должен быть свой стек выполнения, локальные данные, доступы к ресурсам процесса и доступ к ресурсам процессора. Это одно из его ключевых отличий. Ещё одно *отличие потоков от процессов* заключается в том, что **поток зависим от своего процесса**. Поток является потомком процесса, и все потоки внутри одного процесса используют одно адресное пространство. Это означает, что если у вас есть процесс с 10 потоками, то, несмотря на то, что эти потоки физически различны, у них есть один родитель. Все они относятся к одному и тому же процессу и имеют доступ к одним и тем же ресурсам этого процесса.

Различные подходы в операционных системах к потокам показывают, что потоки — это более лёгковесные структуры данных по сравнению с процессами, и переключение между ними происходит быстрее.
![[Drawing 2025-01-21 03.34.03.excalidraw]]
На знакомой нам диаграмме, описывающей процесс, мы видим, что изначально процесс считался наименьшей единицей деления с точки зрения операционной системы. Ранее мы не знали ничего о потоках, но даже тогда в процессах существовал их зачаток — тред. Он просто не был представлен в виде, который мы видим в многопоточной системе.

### Однопоточный процесс и многопоточность

В процессах существует **контрольный блок** — структура данных, управляющая процессом. В нём есть:

- **Адресное пространство**, ссылки на разделы памяти;
- **Два стека**: стек ядра и стек пользователя.
![[Drawing 2025-01-21 03.35.04.excalidraw]]
Ранее, в однопоточной системе, был лишь один процесс с одним тредом, но в многопоточной системе всё иначе. Главное отличие заключается в количестве пар стеков:

- Каждый тред в многопоточном процессе имеет **пару стеков** (для ядра и пользователя);
- Имеется специальный **контрольный блок** для каждого треда.

При этом:

- Единый блок управления всем процессом остаётся без изменений.
- Адресное пространство пользователя также остаётся общим для всех потоков процесса.

### **Различия между потоками и процессами**

|**Критерий**|**Потоки**|**Процессы**|
|---|---|---|
|**Адресное пространство**|Потоки разделяют общее адресное пространство процесса.|У каждого процесса своё адресное пространство.|
|**Создание**|Создание потока легче и быстрее.|Создание процесса требует больше ресурсов.|
|**Переключение контекста**|Быстрое переключение между потоками.|Переключение между процессами занимает больше времени.|
|**Ресурсы**|Потоки используют ресурсы родительского процесса.|Процессу выделяются собственные ресурсы.|
|**Изолированность**|Потоки тесно связаны и могут влиять друг на друга.|Процессы изолированы друг от друга.|
|**Применение**|Используются для выполнения параллельных задач внутри одного приложения.|Используются для выполнения независимых программ.|

### Почему многопоточность?

Основная причина — **скорость**. Ускорение работы — универсальная цель в операционных системах и информатике в целом. Благодаря потокам:

- **Создание, уничтожение и переключение между потоками** происходит быстрее, чем аналогичные операции с процессами.
- Потоки могут общаться друг с другом напрямую, минуя ядро, что исключает дорогие обращения к ядру. Это ещё больше увеличивает производительность.

### Особенности управления потоками

Важно учитывать, что решения операционной системы, принимаемые в отношении процесса, влияют на все его потоки. Например:

- Если операционная система решит приостановить процесс, то будут приостановлены все его потоки.
- Это может быть не всегда оптимально и иногда вызывает проблемы. Например, если один поток ожидает завершения задачи, а остальные могут продолжать работу, глобальная приостановка всех потоков выглядит как "топорный подход".

### Состояние и синхронизация потоков

У потоков, как и у процессов, есть состояние. Они могут:

- Синхронизироваться друг с другом;
- Работать параллельно, эффективно распределяя задачи.

Мы пытались понять, зачем были придуманы процессы, и выяснили, что их изначальная задача заключалась в том, чтобы эффективно использовать процессорное время. Часто процессор простаивал в ожидании ответа от медленных устройств. С потоками решается аналогичная проблема, но на более высоком уровне.

### Пример с запросами к удалённому серверу

Допустим, у нас есть приложение, которому нужно сделать два запроса к удалённому серверу. Запрос к удалённому серверу — это чудовищно медленная операция, особенно если сравнивать её со скоростью работы процессора. Даже с быстрым интернет-соединением обращение к сетевой карте — уже медленная операция, не говоря о том, чтобы послать запрос в другую часть планеты.

Если у нас есть только один тред, то процесс выглядит так:
![[Drawing 2025-01-21 03.35.53.excalidraw]]
1. Мы делаем первый запрос и ждём его ответа.
2. После завершения первого запроса мы делаем второй запрос и снова ждём его ответа.

В результате значительная часть времени тратится впустую, так как процессор просто ждёт.

### Решение с использованием потоков

Если бы у нас было несколько потоков в этом процессе, задача решалась бы намного эффективнее:
![[Drawing 2025-01-21 03.36.24.excalidraw]]
1. Мы делаем первый запрос и начинаем ждать.
2. Вместо того чтобы простаивать, мы создаём второй поток, в котором делаем второй запрос.
3. Оба потока работают параллельно, и большая часть времени ожидания первого и второго запросов пересекается.

#### Эффективность

- Время ожидания уменьшается почти вдвое, так как оба запроса выполняются одновременно.
- Когда первый запрос возвращает ответ, процессор переключается на обработку полученной информации.
- Затем обрабатывается ответ второго запроса.

Таким образом, мы не теряем время, а эффективно используем возможности системы.

### Особенности многопоточности

Хотя кажется, что треды работают параллельно, на самом деле это не так. В один момент времени процессор выполняет задачи только одного треда, а остальные треды приостанавливаются. Однако благодаря высокой скорости переключения между потоками создаётся иллюзия их одновременного выполнения.

### Синхронизация потоков

После завершения обоих запросов приложение может объединить результаты, синхронизировав работу потоков. Это позволяет эффективно обработать оба ответа и продолжить выполнение задачи.

Концептуально здесь ничего нового:

- Мы разделили процесс на подпроцессы (треды), которые легче и быстрее.
- Управление тредами частично вынесли из операционной системы, сделав его более локальным и независимым.

Этот подход — ещё один шаг вверх по лестнице абстракции. Мы всё дальше отходим от работы с инструкциями процессора и переходим на уровни, где задачи описываются и решаются более высокоуровневыми методами. Это делает системы гибче и удобнее для разработчиков, позволяя сосредоточиться на логике приложений, а не на тонкостях работы железа.

- Используются механизмы синхронизации, такие как мьютексы, семафоры и блокировки.

### **Создание и управление потоками на C**

В языке C потоки можно создавать с использованием библиотеки **POSIX Threads (pthreads)**, которая является стандартом в большинстве UNIX-подобных операционных систем.

**Пример создания потока с помощью pthreads**:
```c
#include <pthread.h>
#include <stdio.h>
#include <stdlib.h>

void* thread_function(void* arg) {
    printf("Hello from thread! Argument: %d\n", *(int*)arg);
    return NULL;
}

int main() {
    pthread_t thread;
    int thread_arg = 42;

    // Создание потока
    if (pthread_create(&thread, NULL, thread_function, &thread_arg) != 0) {
        perror("Failed to create thread");
        exit(1);
    }

    // Ожидание завершения потока
    pthread_join(thread, NULL);

    printf("Thread has finished.\n");
    return 0;
}
```

1. `pthread_create` создаёт новый поток.
    
    - Первый аргумент: указатель на переменную типа `pthread_t` для хранения идентификатора потока.
    - Второй аргумент: атрибуты потока (можно передать `NULL` для значений по умолчанию).
    - Третий аргумент: функция, которую выполнит поток.
    - Четвёртый аргумент: данные, передаваемые в поток.
2. `pthread_join` используется для ожидания завершения потока.
    

---

### **Мьютексы: управление доступом к общим ресурсам**

**Мьютекс** (mutex, сокращение от "mutual exclusion") — это механизм синхронизации, используемый для предотвращения одновременного доступа нескольких потоков к общим данным. Он гарантирует, что только один поток может работать с критическим участком кода в определённый момент времени.

**Пример использования мьютекса**
```c
#include <pthread.h>
#include <stdio.h>
#include <stdlib.h>

#define NUM_THREADS 5

pthread_mutex_t mutex; // Мьютекс
int shared_resource = 0; // Общий ресурс

void* thread_function(void* arg) {
    int id = *(int*)arg;

    // Захват мьютекса
    pthread_mutex_lock(&mutex);

    // Критический участок
    printf("Thread %d is incrementing shared_resource.\n", id);
    shared_resource++;
    printf("Thread %d incremented shared_resource to %d.\n", id, shared_resource);

    // Освобождение мьютекса
    pthread_mutex_unlock(&mutex);

    return NULL;
}

int main() {
    pthread_t threads[NUM_THREADS];
    int thread_ids[NUM_THREADS];

    // Инициализация мьютекса
    if (pthread_mutex_init(&mutex, NULL) != 0) {
        perror("Mutex init failed");
        exit(1);
    }

    // Создание потоков
    for (int i = 0; i < NUM_THREADS; i++) {
        thread_ids[i] = i + 1;
        if (pthread_create(&threads[i], NULL, thread_function, &thread_ids[i]) != 0) {
            perror("Failed to create thread");
            exit(1);
        }
    }

    // Ожидание завершения потоков
    for (int i = 0; i < NUM_THREADS; i++) {
        pthread_join(threads[i], NULL);
    }

    // Уничтожение мьютекса
    pthread_mutex_destroy(&mutex);

    printf("Final value of shared_resource: %d\n", shared_resource);
    return 0;
}

```
1. **Инициализация мьютекса:**
    
    - Используется функция `pthread_mutex_init`.
2. **Захват мьютекса:**
    
    - `pthread_mutex_lock` захватывает мьютекс, блокируя доступ другим потокам к критическому участку кода.
3. **Критический участок:**
    
    - Код между `pthread_mutex_lock` и `pthread_mutex_unlock` исполняется только одним потоком в любой момент времени.
4. **Освобождение мьютекса:**
    
    - `pthread_mutex_unlock` освобождает мьютекс, позволяя другим потокам продолжить выполнение.
5. **Уничтожение мьютекса:**
    
    - После завершения работы с мьютексом его нужно уничтожить с помощью `pthread_mutex_destroy`.


### **Особенности потоков и использование мьютексов**

1. **Общий доступ к ресурсам:**
    
    - Потоки разделяют память, что упрощает обмен данными, но требует синхронизации.
    - Мьютексы предотвращают состояния гонки (race conditions).
2. **Производительность:**
    
    - Потоки быстрее процессов, так как переключение контекста между потоками требует меньше ресурсов.
    - Использование мьютексов минимизирует затраты на синхронизацию.
3. **Правильное использование мьютексов:**
    
    - Никогда не оставляйте мьютекс заблокированным на долгий срок.
    - Убедитесь, что каждый `pthread_mutex_lock` имеет соответствующий `pthread_mutex_unlock`.
    - Избегайте взаимоблокировок (deadlocks).

---

### **Заключение**

Потоки позволяют эффективно управлять параллельными задачами внутри одного процесса. Мьютексы обеспечивают безопасный доступ к общим ресурсам, предотвращая конфликты между потоками. Использование библиотеки `pthreads` в C даёт гибкость и контроль над потоками и синхронизацией, что делает её стандартным выбором для низкоуровневой многопоточной разработки.
