# **Основные свойства и атрибуты файла. Механизм установки и управления правами доступа**

### Основные свойства файла

Файлы в операционных системах имеют следующие ключевые свойства:

1. **Имя файла:** Человекочитаемое имя, используемое для идентификации файла.
2. **Размер файла:** Количество байтов, занимаемое файлом на диске.
3. **Тип файла:**
    - Обычные файлы (текстовые, бинарные).
    - Каталоги (директории).
    - Специальные файлы (устройства, сокеты, каналы).
4. **Расположение:** Полный путь к файлу в файловой системе.
5. **Дата и время:**
    - Время создания файла.
    - Время последнего изменения.
    - Время последнего доступа.
6. **Ссылки:** Количество ссылок на файл.
7. **Идентификаторы владельца и группы:**
    - **UID** (User ID) — идентификатор владельца.
    - **GID** (Group ID) — идентификатор группы.
8. **Права доступа:** Разрешения на чтение, запись и выполнение файла для различных пользователей.


### Атрибуты файла

1. ***Статусные атрибуты:***
Эти атрибуты можно просмотреть с помощью команды `ls -l`:

- *Тип файла*:
    - `-` — обычный файл.
    - `d` — каталог.
    - `l` — символическая ссылка.
- *Права доступа:* Пример: `-rwxr-xr--`.
- *Количество ссылок на файл.*
- *Идентификатор владельца и группы:* Например, `user:group`.
- *Размер файла в байтах.*
- *Дата и время последнего изменения.*

2. ***Расширенные атрибуты:***
Некоторые файловые системы поддерживают расширенные атрибуты (ACL, xattr), которые позволяют задавать более сложные настройки прав доступа.


### Типы ссылок

В Unix-подобных системах существует два типа ссылок на файлы:

1. ***Жёсткие ссылки (Hard Links):***

- Указывают на один и тот же индексный дескриптор (inode) в файловой системе.
- Все жёсткие ссылки равнозначны: удаление одной ссылки не удаляет файл, пока существуют другие ссылки.
- Невозможно создать жёсткую ссылку на директорию (во избежание циклических структур).
- Создание жёсткой ссылки:
    
    ```bash
    ln source_file hard_link_name
    ```
    
- Пример:
    
    ```bash
    ln file.txt file_link.txt
    ```
    
    Теперь оба файла указывают на один и тот же inode.

2. ***Символические ссылки (Symbolic Links):***

- Представляют собой отдельный файл, содержащий путь к исходному файлу.
- Если исходный файл удаляется, символическая ссылка становится «сломанной».
- Можно создать ссылку на директорию.
- Создание символической ссылки:
    
    ```bash
    ln -s source_file symbolic_link_name
    ```
    
- Пример:
    
    ```bash
    ln -s file.txt file_symlink.txt
    ```
    
    Теперь `file_symlink.txt` указывает на `file.txt`.

|**Свойство**|**Жёсткая ссылка**|**Символическая ссылка**|
|---|---|---|
|Зависимость от файла|Нет|Да|
|Ссылка на директорию|Нельзя|Можно|
|Указатель на inode|Да|Нет|
|Работа при удалении файла|Файл остаётся доступным|Ссылка становится недействительной|

---
### Права доступа

Файлы и каталоги в Unix-подобных системах имеют следующие типы разрешений:

1. **Чтение (r):** Разрешает просмотр содержимого файла или списка файлов в каталоге.
2. **Запись (w):** Разрешает изменение содержимого файла или добавление/удаление файлов в каталоге.
3. **Выполнение (x):** Разрешает выполнение файла как программы или доступ к каталогу.

#### Уровни доступа:

1. **Владелец (owner):** Пользователь, который создал файл.
2. **Группа (group):** Группа пользователей, которые могут иметь общий доступ к файлу.
3. **Прочие (others):** Все остальные пользователи системы.



### Механизм управления правами доступа

#### 1. **Команда `chmod`:** Изменение прав доступа к файлу.

- **Символьный режим:**
    
    ```bash
    chmod u+r file.txt   # Добавить право чтения владельцу
    chmod g-w file.txt   # Убрать право записи группе
    chmod o+x file.txt   # Добавить право выполнения для прочих
    ```
    
- **Октальный режим:**
    
    ```bash
    chmod 755 file.txt   # Права: rwxr-xr-x
    chmod 644 file.txt   # Права: rw-r--r--
    ```
    
Каждое право выражается одним из трех битов:

|**Бит**|**Символ**|**Описание**|
|---|---|---|
|`4`|`r`|Чтение (read)|
|`2`|`w`|Запись (write)|
|`1`|`x`|Исполнение (execute)|

Числовое значение прав складывается для задания комбинации:
- `rwx` = `4 + 2 + 1 = 7`
    
- `rw-` = `4 + 2 + 0 = 6`
    
- `r--` = `4 + 0 + 0 = 4`
    

Пример:
- `755` → Владелец: `7` (rwx), Группа: `5` (r-x), Прочие: `5` (r-x).
    

---

#### 2. **Команда `chown`:** Изменение владельца и группы файла.

- Изменить владельца:
    
    ```bash
    chown user file.txt
    ```
    
- Изменить владельца и группу:
    
    ```bash
    chown user:group file.txt
    ```
    

#### 3. **Команда `chgrp`:** Изменение группы файла.

- Пример:
    
    ```bash
    chgrp group file.txt
    ```
    

#### 4. **Команда `umask`:** Устанавливает маску создания новых файлов.

- Пример:
    ```bash
    umask 022
    ```
    
    Маска `022` запрещает запись для группы и прочих при создании нового файла.
    
**umask 022** вычитает:
- `0` для владельца (нет ограничений, владелец сохраняет все права).
- `2` для группы (запись запрещена для группы).
- `2` для остальных (запись запрещена для остальных).
    
- Для **директорий*:
    - По умолчанию: `777`
    - `777 - 022 = 755`
    - Итоговые права: `rwxr-xr-x`
- Для **файлов**:
    - По умолчанию: `666`
    - `666 - 022 = 644`
    - Итоговые права: `rw-r--r--`

---

### Расширенные права доступа

#### 1. **SUID и SGID:**

- **SUID (Set User ID):** При выполнении программы процесс получает права владельца файла.
    
- **SGID (Set Group ID):** При выполнении программы процесс получает права группы файла.
    
- Установка флагов: 
    ```bash
    chmod u+s file   # Установить SUID
    chmod g+s file   # Установить SGID
    ```
    

#### 2. **Sticky Bit:**

- Используется для директорий. Позволяет удалять файлы в каталоге только их владельцам.
- Установка Sticky Bit:
    
    ```bash
    chmod +t directory
    ```

---

### Примеры работы с правами доступа

1. **Просмотр прав доступа:**
    ```bash
    ls -l file.txt
    ```
    
    Вывод:
    ```
    -rw-r--r-- 1 user group 1024 Jan 1 12:00 file.txt
    ```
    
2. **Изменение прав доступа для владельца:**
    ```bash
    chmod u+x script.sh
    ```
    
3. **Изменение владельца файла:** 
    ```bash
    chown new_user file.txt
    ```
    
4. **Установка прав для группы и прочих:**
    
    ```bash
    chmod go-rw file.txt
    ```
    
5. **Работа с SUID и SGID:**
    
    ```bash
    chmod u+s program
    chmod g+s shared_folder
    ```
    
6. **Работа с Sticky Bit:**
    
    ```bash
    chmod +t /shared_directory
    ```
    

|**Характеристика**|**`chown`**|**`chmod`**|
|---|---|---|
|**Назначение**|Изменяет владельца и/или группу файла или каталога.|Изменяет права доступа (чтение, запись, выполнение).|
|**Что изменяет**|Владелец (`owner`) и группа (`group`).|Разрешения для владельца, группы и прочих.|
|**Пример использования**|`chown user:group файл.txt`|`chmod 755 файл.txt`|
|**Уровень управления**|Управляет правами собственности.|Управляет правами доступа.|


### Заключение

Механизмы установки и управления правами доступа обеспечивают безопасность и разграничение прав пользователей в операционной системе. Понимание основных команд (`chmod`, `chown`, `ls -l`) и концепций (SUID, SGID, Sticky Bit) является ключевым для эффективного администрирования и работы в Unix-подобных системах.



 # Описание файловых систем в Unix-подобных системах. Файл, операции над файлом и их программный интерфейс.

В Unix все представлено как файл: обычные файлы, директории, устройства ввода-вывода, сокеты и каналы.
Понятие *файла* в Unix - это некоторая абстракция, которая предоставляет нам интерфейс для чтения и записи данных. Каждый файл ассоциирован с дескриптором, который является индексом таблицы открытых файлов процесса. А *файловая система* (FS) - это способ организации файлов. 


У каждой OS есть своя или свои FS (модуль OS).
Для Windows - NTFS
Для Linux - ext4
Для MacOS - AppleFS


В Unix-подобных системах FS образует 1 дерево:
![[Pasted image 20250121034852.png]]


- *bin* - хранятся бинарных файлов (хранятся программные файлы)
- *lib* - хранятся программных библиотек
- *urs* - локальные, личные программы
- *home* - папки для каждого пользователя 
- *etc* - храненятся конфигурированные программы 
- *tmp* - в основном для временных файлов
- *dev* - девайсы (мышка, клавиатура, монитор и др)


#### Типы файлов


1. Регулярные
        - Содержат данные (текст, двоичные данные, изображения и т.д.).
        - Доступ осуществляется через системные вызовы (`read`, `write`).
        
2. Директории
        - Хранят записи о файлах и их атрибутах.
        - Доступ через системные вызовы (`opendir`, `readdir`, `closedir`).
        
3. Девайсы
        - Специальные файлы, представляющие устройства (например, `/dev/sda`, `/dev/null`).
        - Бывают **символьными** (character devices) и **блочными** (block devices).
        
4. Сокет 
        - **Сокеты** — файлы для сетевого взаимодействия.


#### Типы ссылок


1. symlink - Символические ссылки
        Символическая ссылка — это специальный файл, который содержит путь к другому файлу или каталогу.
2. hard link - жесткие ссылки
        Жесткая ссылка — это прямой указатель на данные (inode) существующего файла.


Нет понятия удаления файла, есть понятие unlink, т.е. удаляем все жесткие ссылки, указывающие на данный файл


#### Операции над файлами


*Файловый дескриптор (fd)* - неотрицательное число, закрепленное за определенным потоков ввода-вывода. По умолчанию Unix-оболочки связывают файловый дескриптор 0 с потоком стандартного ввода (клавиатура), файловый дескриптор 1 — с потоком стандартного вывода (терминал), и файловый дескриптор 2 — со стандартным выводом ошибок (диагностические и отладочные сообщения, информация об ошибках).


1. **Открытие файла**
        Системный вызов `open()`:
```
int fd = open(const char* path, int oflag, int mode);
```
Возвращает первый свободный файловый дескриптор.
*Флаги:*
- O_CREAT - если файла не существует, то он создаётся. Если флаг отсутствует может возникнуть ошибка
- O_RDONLY - файл только для чтения
- O_WRONLY - файл только для записи
- O_RDWR - файл и для чтения, и для записи
- O_TRUNC - обнуление при открытии файла
- O_ARREND - то, что записывается в файл, записывается в конец
        
2. **Чтение из файла и запись в файл**
        Системные вызовы `read()` и `write()`:
```
int bytes_read = read(int fd (1), void buf[.count] (2), size_t count (3));
int bytes_write = write(int fd, const void buf[.count], size_t count);
```
Возвращают количество прочитанных / записанных байтов
*(1)* - откуда читать/писать
*(2)* - куда
*(3)* - сколько
        
3. **Закрытие файла**
        Системный вызов `close()`
```
int close(int fd);
```
Если файл открыт, то он закроется, если файла нет - произойдет ошибка
        
4. **Дублирование файла**
        Функции `dup()`, `dup2()` и `dup3()`:
        - `dup()`: Создает дубликат файлового дескриптора, возвращает новый дескриптор с наименьшим доступным числом.
        - `dup2()`: Позволяет указать номер нового дескриптора.
        - `dup3()`: Позволяет также указать флаги
        
    Возвращает новый файловый дескриптор, если операция выполнена успешно, -1 в случае ошибки.
```
int dup(int oldfd);
int dup2(int oldfd, int newfd);
int dup3(int oldfd (1), int newfd (2), int flags (3));
```
- *(1)*: Исходный файловый дескриптор, который нужно дублировать.
- *(2)*: Целевой файловый дескриптор, который будет заменен.
- *(3)*: Дополнительные флаги. Единственный допустимый флаг — `O_CLOEXEC`:
    - **`O_CLOEXEC`**: Указывает, что новый дескриптор должен быть автоматически закрыт, если процесс вызовет `execve()`.
        
5. **Сдвиги**
Функция `lseek()`
```
off_t lseek(int fd, off_t offset(1), int whence(2));
```
Возвращает количество байтов, на которое был сделан сдвиг.
- *(1)*— смещение от точки отсчета.
- *(2)*(режим сдвига):
    - `SEEK_SET` — начало файла.
    - `SEEK_CUR` — текущая позиция.
    - `SEEK_END` — конец файла.
    - `SEEK_DATA` - перемещает курсор до следующей data
    - `SEEK_HOLE` - перемещает курсор до следующей hole
        Если сделать lseek(fd, 100, SEEK_END), то образуется *hole(дыра)*. Там ничего нет, но это часть файла. Если это прочитать, то будут нули, но физически на диске они не записываются. После дыры также можно записать данные.