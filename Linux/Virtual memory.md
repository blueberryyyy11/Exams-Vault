**Виртуальная память процесса. Структура виртуальной памяти, особенности и работа с физической памятью. Описание механизма клонирования памяти процесса.**

#### Введение

***Основные термины***:
- **Память:** В данном контексте подразумевается оперативная память (ОЗУ), которая является основным ресурсом компьютера.
- **Вторичные носители:** Жесткие диски, SSD и другие постоянные устройства хранения данных.

***Роль памяти в компьютерах***:
- Компьютеры могут работать без постоянных носителей, но без оперативной памяти работа невозможна.
- Память используется для работы операционной системы (ОС) и программ.

***Абстракция памяти***:
- Память представляется как набор ячеек с адресами.
- Для программиста не имеет значения физическое расположение программы или её данных в памяти.

***Основные задачи ОС в управлении памятью***:
1. **Распределение:** Назначение памяти процессам.
2. **Защита:** Обеспечение изолированного доступа к памяти.
3. **Разделение:** Совместное использование памяти процессами.
4. **Логическая организация:** Абстрагирование памяти для программ.
5. **Физическая организация:** Организация на уровне оборудования.

### Подкачка страниц и виртуальная память

##### Основные идеи

- Память делится на логические страницы, которые соответствуют физическим блокам (фреймам).
- **Таблица страниц:** Сопоставление логических страниц процессора с физической памятью.
  ![[Pasted image 20250120230655.png]]
  Когда процесс обращается к памяти, он видит иллюзию идеального, непрерывного и последовательного пространства (синий блок слева). С его точки зрения, память предоставлена в виде страниц, каждая из которых упорядочена и связана. Процесс может подумать: «Здорово! У меня есть ровный, непрерывный кусок памяти. Это просто идеально!» Однако реальность значительно сложнее.

За кулисами операционная система работает над тем, чтобы отобразить эти виртуальные страницы на физическую память. Логические страницы, видимые процессу, называются **страницами (pages)**, а соответствующие им блоки физической памяти — **фреймами (frames)**. Эти два элемента должны быть одинакового размера, чтобы процесс отображения оставался простым и удобным.

Каждая страница логической памяти связана с фреймом физической памяти через **таблицу страниц (page table)**, которую отслеживает и обновляет операционная система. Например, первая страница виртуальной памяти может соответствовать третьему фрейму физической памяти, а вторая странице — пятому. Процесс не видит этой сложной структуры и продолжает думать, что его память непрерывна.

Операционная система и аппаратный модуль управления памятью (Memory Management Unit, MMU) берут номер страницы, находят соответствующий фрейм в физической памяти и добавляют к нему смещение, чтобы получить точный физический адрес.
![[Pasted image 20250120230801.png]]

Когда процесс обращается к конкретной области памяти, используется два ключевых числа:

1. **Номер страницы (Page Number):** определяет, на какой странице находится данные.
2. **Смещение (Offset):** указывает точное расположение данных внутри страницы.


![[Pasted image 20250120230832.png]]

*И фрейм и пейдж имеют одинаковый размер, поэтому оффсет тоже одинаковый.*

Этот механизм также поддерживает виртуальную память, позволяя временно выгружать страницы на диск, если физической памяти недостаточно. При этом процесс может обращаться к большим объёмам памяти, чем имеется физически, а редко используемые данные хранятся во вторичном хранилище.

### Виртуальная память

Виртуальная память — это механизм, который позволяет компьютеру использовать вторичные носители (например, жесткий диск) для расширения оперативной памяти и предоставления процессам иллюзии непрерывного адресного пространства. Она обеспечивает следующие ключевые возможности:

#### Преимущества виртуальной памяти:

1. **Расширение адресного пространства:**
    - Программы могут обращаться к большему объёму памяти, чем доступно физически.
2. **Изоляция процессов:**
    - Каждый процесс видит своё собственное изолированное адресное пространство.
3. **Эффективное использование памяти:**
    - Неиспользуемые страницы временно выгружаются на диск, освобождая ресурсы.
4. **Обеспечение безопасности:**
    - Защита данных и управление доступом на уровне страниц.
5. **Поддержка многозадачности:**
    - Упрощение работы с несколькими процессами.

### Структура виртуальной памяти

Виртуальная память процесса делится на несколько сегментов:

#### 1. **Текстовый сегмент (Text Segment):**

- Содержит исполняемый код программы.
- Обычно доступен только для чтения.
- Общий для всех процессов, использующих один и тот же код.

#### 2. **Сегмент данных (Data Segment):**

- Хранит глобальные и статические переменные программы.
- Делится на:
    - **Инициализированные данные:** Переменные, которым задано начальное значение.
    - **Неинициализированные данные (.bss):** Переменные, не имеющие начального значения.

#### 3. **Куча (Heap):**

- Используется для динамического выделения памяти во время выполнения программы (например, с помощью `malloc` в C).
- Растёт вверх (к более высоким адресам).

#### 4. **Стек (Stack):**

- Хранит локальные переменные, параметры функций и адреса возврата.
- Растёт вниз (к более низким адресам).
- У каждого треда (потока) есть собственный стек. При создании тредов их области стека располагаются один за другим в памяти, что обеспечивает изоляцию данных между потоками.

#### 5. **Область маппинга (Mapped Segment):**

- Включает динамические библиотеки и файлы, отображённые в память.
- Управляется через вызов `mmap()` (`mmap()` — это системный вызов, который используется для отображения файлов или устройств в адресное пространство процесса. С его помощью можно напрямую работать с файлами, как если бы они были в памяти (типа как с массивом), без необходимости вызвать `read()/write()` для этого).

**Визуализация структуры:**

```
+------------------+  Высокие адреса
|      Стек        |
+------------------+
| Незаполненная    |
|   область памяти |
+------------------+
|      Куча        |
+------------------+
|  Сегмент данных  |
+------------------+
|  Текст программы |
+------------------+  Низкие адреса
```

### Работа с физической памятью

Виртуальная память использует физическую память через механизм отображения (paging). Этот процесс включает:

#### 1. **Таблицы страниц:**

- Таблицы страниц содержат информацию о соответствии виртуальных адресов физическим.
- Каждый виртуальный адрес разбивается на:
    - **Номер страницы (Page Number):** Указывает страницу в таблице.
    - **Смещение (Offset):** Указывает позицию внутри страницы.

#### 2. **Переключение контекста:**

- При переключении процессов операционная система обновляет таблицы страниц, чтобы соответствовать памяти нового процесса.

#### 3. **Кэширование:**

- Translation Lookaside Buffer (TLB) хранит часто используемые отображения страниц для ускорения работы.

#### 4. **Механизм подкачки (Paging):**

- Если физической памяти недостаточно, редко используемые страницы выгружаются в swap (область на диске). Swap работает как расширение оперативной памяти на диске. Если данные снова требуются, они возвращаются обратно в оперативную память, заменяя другие страницы. Для выбора страниц используется алгоритм, такой как LRU (Least Recently Used), который учитывает частоту доступа к данным.
![[Pasted image 20250120231114.png]]
В любой момент времени страница может быть перенесена туда и
обратно во вторичное хранилище. Когда мы обращаемся к странице и
оказалось, что ее нет физически в памяти, значит она находится во вторичном хранилище.
Мы называем это **page fault** и это звучит ужасно, но в этом нет ничего страшного. Eстественно будет задержка, это будет очень медленно, потому что обращение к жесткому диску медленнее, чем обращение к памяти. Поэтому когда процесс обращается к страницам, которые физически находятся во вторичном хранилище, происходит обычно это настолько медленно что в этот момент можно переключиться на другой
процесс и ждать пока там жесткий диск ответит. Когда мы имеем такую систему, то нужно понимать, что это не совсем эффективно потому что мы будем постоянно ждать. Иногда операционна система может предугадать какая страница понадобится и загрузить ее заранее (demand paging, pre-fetching).

#### **Thrashing (пробуксовка)**

**Thrashing** — это ситуация, при которой система тратит чрезмерное количество времени на подкачку страниц между оперативной памятью и вторичным хранилищем (swap), вместо выполнения полезной работы. Это приводит к резкому снижению производительности системы.

***Как работает Thrashing***
1. Процесс пытается получить доступ к странице, которая не находится в оперативной памяти.
2. Операционная система выгружает одну из страниц, чтобы освободить место.
3. Если выгруженная страница снова требуется, она повторно загружается в оперативную память, замещая другую страницу.
4. Этот цикл может повторяться бесконечно, вызывая частые обращения к диску, которые являются медленными.

### Механизм клонирования памяти процесса

Клонирование памяти используется при создании новых процессов (например, с помощью системного вызова `fork()` в Unix). Основные этапы:

#### 1. **Системный вызов fork():**

- Создаёт точную копию текущего процесса.
- Копируются:
    - Таблицы страниц.
    - Контекст процессора.
    - Дескрипторы файлов.

#### 2. **Механизм Copy-on-Write (CoW):**

- Физическая память не копируется сразу. Вместо этого используется общая память с меткой «только для чтения».
- Если один из процессов пытается изменить данные, создаётся копия соответствующей страницы для этого процесса.

**Преимущества Copy-on-Write:**

- **Экономия памяти:** Общая память используется до тех пор, пока не требуется модификация.
- **Ускорение работы:** Новый процесс создаётся быстрее, поскольку копируются только таблицы страниц, а не сами данные.

**Пример работы fork():**

1. Родительский процесс вызывает `fork()`.
2. Создаётся дочерний процесс с копией таблиц страниц.
3. При попытке записи в память система копирует изменяемую страницу для дочернего процесса.

## Оптимизации

##### Предзагрузка страниц

- _Demand Paging:_ Загрузка по требованию.
- _Прогнозируемая загрузка:_ Предугадывание необходимых страниц.

##### Копирование при записи (_Copy-on-Write_)

- Используется при создании копий процессов.
- Память копируется только при её изменении, что экономит ресурсы.

##### Влияние вторичных носителей

- SSD: Быстрее HDD, но имеет ограниченный ресурс перезаписи.
- HDD: Медленный, но более долговечный.


## Заключение

- Современные ОС эффективно управляют памятью благодаря абстракциям виртуальной памяти.
- Проблемы, такие как фрагментация и пробуксовка, остаются актуальными, но решаются за счёт оптимизаций.
- История развития памяти показывает эволюцию решений от простых к сложным, но более эффективным подходам.