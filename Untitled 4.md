
# Потенциальные вопросы для экзамена по ООП

## Блок 1: Ссылки и типы значений
1. Какие из следующих объявлений ссылок на переменную с именем `x` и типом `int` являются правильными?
   - a) `const int& y = x;`
   - b) `auto y = x;`
   - c) `int& y = x;`
   - d) `int&& y = x;`

2. Какие из следующих выражений являются `r-value`?
   - a) `x;`
   - b) `y;`
   - c) `z + 1;`
   - d) `w + 1;`

3. Почему нельзя создать `int&` ссылку на временный объект?

4. Какие ключевые отличия между `const int&` и `int&&`?

5. Что напечатает следующий код?
```cpp
int x = 10;
const int& ref1 = x;
int&& ref2 = std::move(x);
std::cout << ref1 << " " << ref2;
```

---

## Блок 2: Конструкторы и деструкторы
6. Что напечатает следующий код?
```cpp
struct A {
    A() { std::cout << "A"; }
    ~A() { std::cout << "a"; }
};
struct B : A {
    B() { std::cout << "B"; }
    ~B() { std::cout << "b"; }
};
int main() {
    A* ptr = new B;
    delete ptr;
}
```
   - a) ABab
   - b) ABa
   - c) Compilation Error
   - d) Undefined Behavior

7. В каком порядке вызываются конструкторы и деструкторы при создании и уничтожении объекта наследуемого класса?

8. Для класса `Complex` напишите объявление конструктора копирования и конструктора перемещения.

---

## Блок 3: Полиморфизм
9. Какое из следующих утверждений верно?
   - a) Если класс содержит хотя бы одну виртуальную функцию, то он абстрактный.
   - b) Конструктор класса не может принимать объект этого класса по значению.
   - c) Виртуальная функция может быть определена в базовом классе, но переопределена в наследуемом.

10. Что напечатает следующий код?
```cpp
struct A {
    virtual void f() { std::cout << "A"; }
};
struct B : A {
    void f() override { std::cout << "B"; }
};
int main() {
    B obj;
    A& ref = obj;
    ref.f();
}
```
   - a) A
   - b) B
   - c) Compilation Error
   - d) Undefined Behavior

11. В чем отличие `override` и `final` в виртуальных функциях?

12. Можно ли создать объект абстрактного класса через указатель или ссылку?

---

## Блок 4: Перегрузка и переопределение функций
13. Что напечатает следующий код?
```cpp
void print(int x) { std::cout << "int: " << x; }
void print(double x) { std::cout << "double: " << x; }
print(5);
print(5.5);
```
   - a) Ошибка компиляции
   - b) `int: 5` и `double: 5.5`
   - c) Undefined Behavior
   - d) Вывод зависит от компилятора

14. Опишите разницу между function overloading и overriding.

15. Можно ли перегрузить функцию, отличающуюся только возвращаемым типом? Почему?

---

## Блок 5: Шаблоны
16. Напишите шаблонную функцию, которая принимает два аргумента и возвращает их сумму.

17. В чем отличие специализации и перегрузки шаблонов?

18. Напишите шаблонный класс, который имеет поле типа `T` и метод для его вывода.

19. Почему нельзя создать шаблонный метод в не-шаблонном классе?

---

## Блок 6: Исключения
20. Что напечатает следующий код?
```cpp
try {
    throw std::runtime_error("Ошибка");
} catch (const std::exception& e) {
    std::cout << e.what();
}
```
   - a) Ошибка
   - b) Компиляционная ошибка
   - c) Undefined Behavior
   - d) Ничего

21. В чем преимущество использования исключений по сравнению с возвращением кодов ошибок?

22. Что произойдет, если исключение не будет поймано?

---

## Блок 7: Работа с `std::string`
23. Какие члены функции `std::string` вызовутся в следующем коде?
```cpp
std::string str1{"abcd"};
std::string str2 = str1;
std::move(str1);
```
   - a) Move-Constructor
   - b) Copy-Constructor
   - c) Destructor
   - d) Default Constructor

24. Что напечатает следующий код?
```cpp
void h(const std::string& x) {
    std::cout << "1";
}
void h(std::string&& x) {
    std::cout << "2";
}
std::string s = "123";
h(s + "4");
h(s);
h(std::move(s));
```

---

## Блок 8: Операторы
25. Напишите перегрузку оператора `+` для класса `Complex`, чтобы складывать два числа.

26. Что напечатает следующий код?
```cpp
struct C {
    C() { std::cout << "1"; }
    C(const C& other) { std::cout << "2"; }
    C& operator=(const C& other) {
        std::cout << "3";
        return *this;
    }
};
C c1;
C c2 = c1;
c2 = c1;
```

27. Объясните, зачем требуется перегружать оператор `=` при использовании динамической памяти.

---

## Блок 9: Особенности C++
28. Почему важно использовать `std::move` для r-value ссылок?

29. Какие преимущества использования `std::initializer_list`?

30. В чем разница между `std::unique_ptr` и `std::shared_ptr`?

31. Что произойдет при использовании `delete` на `nullptr`?